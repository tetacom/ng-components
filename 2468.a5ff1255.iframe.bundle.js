(self.webpackChunk_ng_components_source=self.webpackChunk_ng_components_source||[]).push([[2468],{"./projects/chart/src/chart/base/series-base.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{c:()=>SeriesBaseComponent});var tslib__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_service_chart_service__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/chart/src/chart/service/chart.service.ts"),_service_scale_service__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./projects/chart/src/chart/service/scale.service.ts"),_service_zoom_service__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./projects/chart/src/chart/service/zoom.service.ts");let SeriesBaseComponent=class SeriesBaseComponent{set config(config){this._config=config}get config(){return this._config}set series(series){this._series=series}get series(){return this._series}constructor(svc,cdr,scaleService,zoomService,element,zone){this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.zone=zone}ngOnInit(){}static#_=this.ctorParameters=()=>[{type:_service_chart_service__WEBPACK_IMPORTED_MODULE_0__.u},{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectorRef},{type:_service_scale_service__WEBPACK_IMPORTED_MODULE_2__.e},{type:_service_zoom_service__WEBPACK_IMPORTED_MODULE_3__.T},{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef},{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone}];static#_2=this.propDecorators={config:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}],series:[{type:_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input}]}};SeriesBaseComponent=(0,tslib__WEBPACK_IMPORTED_MODULE_4__.Cg)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Component)({template:"",standalone:!0}),(0,tslib__WEBPACK_IMPORTED_MODULE_4__.Sn)("design:paramtypes",[_service_chart_service__WEBPACK_IMPORTED_MODULE_0__.u,_angular_core__WEBPACK_IMPORTED_MODULE_1__.ChangeDetectorRef,_service_scale_service__WEBPACK_IMPORTED_MODULE_2__.e,_service_zoom_service__WEBPACK_IMPORTED_MODULE_3__.T,_angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef,_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone])],SeriesBaseComponent)},"./projects/chart/src/chart/chart/chart.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Q:()=>ChartComponent});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");var chart_componentngResource=__webpack_require__("./projects/chart/src/chart/chart/chart.component.scss?ngResource"),chart_componentngResource_default=__webpack_require__.n(chart_componentngResource),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js"),takeWhile=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js"),withLatestFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js"),scale_type=__webpack_require__("./projects/chart/src/chart/model/enum/scale-type.ts"),tooltip_tracking=__webpack_require__("./projects/chart/src/chart/model/enum/tooltip-tracking.ts"),ReplaySubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");let BrushService=class BrushService{constructor(){this._brushDomain=new ReplaySubject.m(1),this.brushDomain=this._brushDomain.asObservable()}setBrush(brush){this._brushDomain.next(brush)}static#_=this.ctorParameters=()=>[]};BrushService=(0,tslib_es6.Cg)([(0,core.Injectable)({providedIn:"root"}),(0,tslib_es6.Sn)("design:paramtypes",[])],BrushService);var chart_service=__webpack_require__("./projects/chart/src/chart/service/chart.service.ts"),scale_service=__webpack_require__("./projects/chart/src/chart/service/scale.service.ts"),zoom_service=__webpack_require__("./projects/chart/src/chart/service/zoom.service.ts");var chart_container_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/chart-container.component.scss?ngResource"),chart_container_componentngResource_default=__webpack_require__.n(chart_container_componentngResource),observeOn=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js"),animationFrame=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js"),shareReplay=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"),combineLatest=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js"),axis_orientation=__webpack_require__("./projects/chart/src/chart/model/enum/axis-orientation.ts"),brush_type=__webpack_require__("./projects/chart/src/chart/model/enum/brush-type.ts"),zoom_type=__webpack_require__("./projects/chart/src/chart/model/enum/zoom-type.ts");var Align,VerticalAlign,tooltip_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/tooltip/tooltip.component.scss?ngResource"),tooltip_componentngResource_default=__webpack_require__.n(tooltip_componentngResource),platform_browser=__webpack_require__("./node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs"),src=__webpack_require__("./node_modules/d3/src/index.js"),tap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/tap.js"),filter=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/filter.js"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs");!function(Align){Align[Align.left=0]="left",Align[Align.right=1]="right",Align[Align.center=2]="center",Align[Align.auto=3]="auto",Align[Align.fitWidth=4]="fitWidth",Align[Align.minWidth=5]="minWidth",Align[Align.outerLeft=6]="outerLeft",Align[Align.outerRight=7]="outerRight",Align[Align.outerAuto=8]="outerAuto"}(Align||(Align={})),function(VerticalAlign){VerticalAlign[VerticalAlign.top=0]="top",VerticalAlign[VerticalAlign.bottom=1]="bottom",VerticalAlign[VerticalAlign.center=2]="center",VerticalAlign[VerticalAlign.auto=3]="auto",VerticalAlign[VerticalAlign.innerTop=4]="innerTop",VerticalAlign[VerticalAlign.innerBottom=5]="innerBottom",VerticalAlign[VerticalAlign.innerAuto=6]="innerAuto"}(VerticalAlign||(VerticalAlign={}));class PositionUtil{static getPosition(containerPosition,elementPosition,align,verticalAlign,margin=0,verticalMargin=0,transformedParentRect={left:0,right:0,top:0,bottom:0}){const rect={},elementWidth=elementPosition.right-elementPosition.left,elementHeight=elementPosition.bottom-elementPosition.top,containerWidth=containerPosition.right-containerPosition.left;containerPosition.bottom,containerPosition.top;return align===Align.auto&&(align=Align.left,window.innerWidth<containerPosition.left+elementWidth&&(align=Align.right)),align===Align.left&&(rect.left=containerPosition.left+margin),align===Align.right&&(rect.left=containerPosition.right-elementWidth-margin),align===Align.center&&(rect.left=(containerPosition.left+containerPosition.right)/2-elementWidth/2),align===Align.outerAuto&&(align=Align.outerRight,window.innerWidth<containerPosition.right+elementWidth&&(align=Align.outerLeft)),align===Align.outerLeft&&(rect.left=containerPosition.left-elementWidth+margin),align===Align.outerRight&&(rect.left=containerPosition.right-margin),align===Align.fitWidth&&(rect.left=containerPosition.left+margin,rect.right=window.innerWidth-containerPosition.right+margin),align===Align.minWidth&&(rect.left=containerPosition.left+margin,rect.minWidth=containerWidth),verticalAlign===VerticalAlign.auto&&(verticalAlign=containerPosition.bottom+elementHeight>window.innerHeight&&containerPosition.bottom>=window.innerHeight/2?VerticalAlign.top:VerticalAlign.bottom),verticalAlign===VerticalAlign.innerAuto&&(verticalAlign=containerPosition.bottom+elementHeight>window.innerHeight&&containerPosition.bottom>=window.innerHeight/2?VerticalAlign.innerTop:VerticalAlign.innerBottom),verticalAlign===VerticalAlign.top&&(rect.top=containerPosition.top-elementHeight-verticalMargin),verticalAlign===VerticalAlign.bottom&&(rect.top=containerPosition.bottom+verticalMargin),verticalAlign===VerticalAlign.innerTop&&(rect.top=containerPosition.bottom-elementHeight-verticalMargin),verticalAlign===VerticalAlign.innerBottom&&(rect.top=containerPosition.top+verticalMargin),verticalAlign===VerticalAlign.center&&(rect.top=(containerPosition.top+containerPosition.bottom)/2-elementHeight/2),rect.left+elementWidth>window.innerWidth&&(rect.left=window.innerWidth-elementWidth),rect.left<0&&(rect.left=0),(rect.top+elementHeight>window.innerHeight||rect.bottom<0)&&(rect.bottom=0),rect.top<0&&(rect.top=0),verticalAlign!==VerticalAlign.bottom&&verticalAlign!==VerticalAlign.center&&verticalAlign!==VerticalAlign.innerBottom||(rect.maxHeight=window.innerHeight-rect.top),verticalAlign!==VerticalAlign.top&&verticalAlign!==VerticalAlign.innerTop||(rect.maxHeight=containerPosition.top),isNaN(rect.left)||(rect.left=rect.left-transformedParentRect.left),isNaN(rect.right)||(rect.right=rect.right-transformedParentRect.left),isNaN(rect.top)||(rect.top=rect.top-transformedParentRect.top),isNaN(rect.bottom)||(rect.bottom=rect.bottom?rect.bottom-transformedParentRect.bottom:rect.bottom),rect}static setElementPosition(element,rect){element.style.left=null!=rect.left?`${rect.left}px`:"",element.style.right=null!=rect.right?`${rect.right}px`:"",element.style.top=null!=rect.top?`${rect.top}px`:"",element.style.bottom=null!=rect.bottom?`${rect.bottom}px`:"",element.style.maxHeight=null!=rect.maxHeight?`${rect.maxHeight}px`:"",element.style.minWidth=null!=rect.minWidth?`${rect.minWidth}px`:""}static getMaxHeight(position){let maxHeight=null;return maxHeight=1,1}static getMaxWidth(position){let maxWidth=null;return maxWidth=1,1}}let TooltipComponent=class TooltipComponent{constructor(svc,cdr,zoomService,sanitizer,_zone,_elementRef){this.svc=svc,this.cdr=cdr,this.zoomService=zoomService,this.sanitizer=sanitizer,this._zone=_zone,this._elementRef=_elementRef,this.tooltips=this.svc.tooltips.pipe((0,map.T)((_=>[..._.values()])))}getImplicit(t){return{$implicit:t}}ngOnInit(){this.display=this.svc.pointerMove.pipe((0,map.T)((event=>"mousemove"===event.type?1:0)),(0,tap.M)((()=>{setTimeout((()=>{this.cdr.detectChanges()}))}))),this.position=this.svc.pointerMove.pipe((0,filter.p)((event=>!!event)),(0,map.T)((_=>this.getPosition(_))),(0,tap.M)((()=>this.cdr.detectChanges())));const transformHtml=html=>this.sanitizer.bypassSecurityTrustHtml(html),formatter=this.config?.tooltip?.format;this.displayTooltips=this.svc.tooltips.pipe((0,map.T)((tooltips=>{const tooltipList=[...tooltips.values()];if(tooltipList?.length<1)return"";const formatted=formatter?transformHtml(formatter(tooltipList)):(tooltips=>{let html="";const format=src.DCK("%d.%m.%Y");return tooltips.forEach((_=>{html+=`<div class='display-flex align-center'><span class='margin-right-1' style='display:block; width: 10px; height: 2px; background-color: ${_?.series?.color}'></span>\n          <span class='font-title-3'>${_.series.name}\n            <span class='font-body-3'>\n              x: ${_.point.x instanceof Date?format(_.point.x):_.point.x?.toFixed(2)}\n              y: ${_.point.y instanceof Date?format(_.point.y):_.point.y?.toFixed(2)}\n            </span>\n          </span></div>`})),transformHtml(html)})(tooltipList);return formatted})))}getPosition(event){return this.tooltip?PositionUtil.getPosition({top:event.pageY,bottom:event.pageY,left:event.pageX,right:event.pageX},this.tooltip?.nativeElement?.getBoundingClientRect(),Align.auto,VerticalAlign.top,12):null}format(input){if(input instanceof Date){return src.DCK("%d.%m.%Y")(input)}return src.GPZ(",.5~r")(input)}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:zoom_service.T},{type:platform_browser.DomSanitizer},{type:core.NgZone},{type:core.ElementRef}];static#_2=this.propDecorators={size:[{type:core.Input}],config:[{type:core.Input}],tooltip:[{type:core.ViewChild,args:["tooltip",{static:!1,read:core.ElementRef}]}]}};TooltipComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"teta-tooltip",template:'@if ({p: position | async}; as data) {\n  @if ((tooltips | async); as t) {\n    @if (t.length > 0) {\n      <div class="chart-tooltip color-text-90 bg-global-bgcard shadow-2"\n           #tooltip\n           [style.position]="\'fixed\'"\n           [style.opacity]="display | async"\n           [hidden]="!data.p"\n           style="pointer-events: none; min-width: 200px;"\n           [style.left.px]="data.p?.left"\n           [style.top.px]="data.p?.top"\n           [style.bottom.px]="data.p?.bottom"\n           [style.right.px]="data.p?.right">\n        @if (config.tooltip?.template) {\n          <ng-container *ngTemplateOutlet="config.tooltip.template; context: getImplicit(t)"></ng-container>\n        }\n        @if (config.tooltip?.format) {\n          <div [innerHTML]="displayTooltips | async"></div>\n        } @else {\n          @if (!config.tooltip?.template) {\n            <div class="padding-2 border-radius-1">\n              @for (tooltip of t; track tooltip) {\n                <div class="display-flex align-center">\n              <span class="display-block margin-right-1" [style.width.px]="10" [style.height.px]="2"\n                    [style.background-color]="tooltip.series?.color">\n              </span>\n                  <span class="font-title-3">\n                {{ tooltip.series?.name }}\n                    <span class="font-body-3">\n                  x: {{ format(tooltip.point?.x) }}\n                      y: {{ format(tooltip.point?.y) }}\n                </span>\n              </span>\n                </div>\n              }\n            </div>\n          }\n        }\n      </div>\n    }\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe,common.NgTemplateOutlet],styles:[tooltip_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,zoom_service.T,platform_browser.DomSanitizer,core.NgZone,core.ElementRef])],TooltipComponent);var x_axis_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/x-axis/x-axis.component.scss?ngResource"),x_axis_componentngResource_default=__webpack_require__.n(x_axis_componentngResource),BehaviorSubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),get_text_width=__webpack_require__("./projects/chart/src/chart/core/utils/get-text-width.ts");let XAxisComponent=class XAxisComponent{constructor(scaleService,_svc){this.scaleService=scaleService,this._svc=_svc,this.update$=new BehaviorSubject.t(null),this._alive=!0,this.x=this.scaleService.scales.pipe((0,map.T)((_=>_.x.get(this.axis.index)?.scale))),this.ticks=(0,combineLatest.z)([this.x,this.update$]).pipe((0,withLatestFrom.E)(this._svc.size),(0,map.T)((_=>{const[[x],size]=_,tickSize=x.ticks().map((_=>(0,get_text_width.q)(this.axis.options.tickFormat?this.axis.options.tickFormat(_):this.axis.defaultFormatter()(_),.45,11)));return x.ticks(size.width/parseInt(src.T9B(tickSize),10)/5)})))}getLabelTransform(){return`translate(${this.size.width/2}, ${this.axis.options.opposite?-32:32})`}ngOnInit(){}ngOnDestroy(){this._alive=!1}ngOnChanges(changes){changes.hasOwnProperty("axis")&&this.update$.next()}static#_=this.ctorParameters=()=>[{type:scale_service.e},{type:chart_service.u}];static#_2=this.propDecorators={axis:[{type:core.Input}],size:[{type:core.Input}]}};XAxisComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-x-axis]",template:'@if ({x: x | async, ticks: ticks | async}; as data) {\n  @for (tick of data.ticks; track tick) {\n    <svg:g text-anchor="middle" [attr.transform]="\'translate(\'+ data.x(tick) +\', 0)\'">\n      <text fill="var(--color-text-70)" [attr.dy]="axis.options.opposite ? \'-0.71em\' : \'0.71em\'"\n            [attr.y]="axis.options.opposite ? 0 : 9">\n        {{ this.axis.options.tickFormat ? this.axis.options.tickFormat(tick) : this.axis.defaultFormatter()(tick) }}\n      </text>\n      <line stroke="var(--color-text-30)" [attr.y2]="axis.options.opposite ? -6 : 6"></line>\n    </svg:g>\n  }\n  <svg:g class="label-axis font-caption" [attr.transform]="getLabelTransform()">\n    <text fill="var(--color-text-70)" text-anchor="middle" dominant-baseline="middle">\n      {{ axis.options.title }}\n    </text>\n  </svg:g>\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe],styles:[x_axis_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[scale_service.e,chart_service.u])],XAxisComponent);var i_broadcast_message=__webpack_require__("./projects/chart/src/chart/model/i-broadcast-message.ts"),zoom_behavior_type=__webpack_require__("./projects/chart/src/chart/model/enum/zoom-behavior-type.ts");let ZoomableDirective=class ZoomableDirective{mouseenter(){this.zoom?.on("start zoom end",this.zoomed),this._element?.call(this.zoom).on("dblclick.zoom",null),this.config?.zoom?.zoomBehavior===zoom_behavior_type.u.wheel&&this.runWheelTranslate()}mouseleave(){this.zoom?.on("start zoom end",null),this._element?.on("wheel",null)}constructor(elementRef,zoomService,chartService,zone){this.elementRef=elementRef,this.zoomService=zoomService,this.chartService=chartService,this.zone=zone,this.zoomable=!1,this.crosshair=!1,this.alive=!0,this.currentTransform=src.GSI,this.zoomed=event=>{if(event.sourceEvent&&(this.elementRef.nativeElement===event.sourceEvent.target||this.elementRef.nativeElement.contains(event.sourceEvent.target))){if(0!==Object.keys(event.sourceEvent).length){const origin=this.axis.scale.copy().domain(this.axis.originDomain);if(this.axis.options.scaleType.type===scale_type.b.band)return;const domain=this.axis.orientation===axis_orientation.U.y?event.transform.rescaleY(origin).domain():event.transform.rescaleX(origin).domain();if(null===domain[0]||void 0===domain[0]||null===domain[1]||void 0===domain[1]||Math.abs(domain[0]-domain[1])<1e-6)return;const message=new i_broadcast_message.T({eventType:event.type,axis:{index:this.axis.index,orientation:this.axis.orientation},element:this.elementRef,domain,chartId:this.config.id});this.zoomService.fireZoom(message),this.zoomService.broadcastZoom(message)}this.currentTransform=event.transform}}}ngOnInit(){(this.axis?.options?.zoom||this.config?.zoom?.enable)&&(this.zoomable=this.config?.zoom?.zoomBehavior===zoom_behavior_type.u.move&&!this.config?.tooltip?.showCrosshair,this.crosshair=this.config?.tooltip?.showCrosshair)}ngAfterViewInit(){this.initZoomListeners(),this.initZoomSync()}ngOnDestroy(){this.zoom?.on("start zoom end",null),this._element?.on("wheel",null),this.alive=!1}initZoomSync(){this.zoomService.zoomed.pipe((0,takeWhile.v)((()=>this.alive))).subscribe((zoomed=>{if(this._element&&this.elementRef!==zoomed?.element&&zoomed?.axis?.index===this.axis.index&&zoomed?.axis?.orientation===this.axis.orientation){const scale=this.axis.scale.copy().domain(this.axis.originDomain);let transform;transform=null===zoomed.domain?src.GSI:this.zoomService.getD3Transform(zoomed.domain,this.axis.originDomain,scale,this.axis.orientation,this.axis.options.inverted),this._element.call(this.zoom.transform,transform),this.currentTransform=transform}}))}initZoomListeners(){if(!(this.axis?.options?.zoom&&!1!==this.axis?.options.visible||this.config?.zoom?.enable))return;this._element=src.Ltv(this.elementRef.nativeElement),this.zoom=src.s_O().extent([[0,0],[this.size.width,this.size.height]]);const min=null!=this.config?.zoom?.minTranslate?this.axis.scale(this.config?.zoom?.minTranslate):-1/0,max=null!=this.config?.zoom?.maxTranslate?this.axis.scale(this.config?.zoom?.maxTranslate):1/0;if(this.axis.orientation===axis_orientation.U.x&&this.config.zoom.type===zoom_type.C.x&&this.zoom.translateExtent([[Math.min(min,max),-1/0],[Math.max(min,max),1/0]]),this.axis.orientation===axis_orientation.U.y&&this.config.zoom.type===zoom_type.C.y&&this.zoom.translateExtent([[-1/0,Math.min(min,max)],[1/0,Math.max(min,max)]]),this.config.zoom?.wheelDelta&&this.zoom.wheelDelta(this.config.zoom?.wheelDelta),this.config?.zoom?.wheelFilter&&this.zoom.filter(this.config?.zoom?.wheelFilter),this.axis.options.scaleType.type!==scale_type.b.band){const extremes=this.axis.extremes,maxZoom=this.config.zoom?.max?(extremes[1]-extremes[0])/this.config.zoom?.max:this.config.zoom?.limitZoomByData?1:0,minZoom=this.config.zoom?.min?(extremes[1]-extremes[0])/this.config.zoom?.min:1/0;this.zoom.scaleExtent([maxZoom,minZoom])}this.config?.zoom?.zoomBehavior===zoom_behavior_type.u.wheel&&this.runWheelTranslate()}runWheelTranslate(){let wheeling,type="start";this.zoom.on("start zoom end",this.zoomed),this._element?.call(this.zoom),this.zoom.filter((event=>event.ctrlKey&&"wheel"===event.type||Boolean(window.TouchEvent&&"wheel"!==event.type))).wheelDelta((event=>.002*(this.config?.zoom.type===zoom_type.C.x?-event.deltaX:-event.deltaY)));const emit=(type,event)=>{const origin=this.axis.scale.copy().domain(this.axis.originDomain);let transform=src.GSI;const delta="end"===type?0:this.axis.orientation===axis_orientation.U.y?event.deltaY:event.deltaX;this.axis.orientation===axis_orientation.U.y&&(transform=transform.translate(0,this.currentTransform.y-delta/2)),this.axis.orientation===axis_orientation.U.x&&(transform=transform.translate(this.currentTransform.x-delta/2,0)),transform=transform.scale(this.currentTransform.k);let domain=this.axis.orientation===axis_orientation.U.y?transform.rescaleY(origin).domain():transform.rescaleX(origin).domain();const extent=this.axis.options?.inverted?domain:[...domain].reverse();if(extent[0]<=this.config.zoom?.minTranslate)return;if(extent[1]>=this.config.zoom?.maxTranslate)return;const message=new i_broadcast_message.T({eventType:type,element:this.elementRef,axis:{index:this.axis.index,orientation:this.axis.orientation},domain,chartId:this.config.id});this._element?.call(this.zoom.transform,transform),this.zoomService.fireZoom(message),this.zoomService.broadcastZoom(message),this.currentTransform=transform};this._element.on("wheel",(event=>{event.preventDefault(),event.ctrlKey||this.zone.runOutsideAngular((()=>{clearTimeout(wheeling),emit(type,event),type="zoom",wheeling=setTimeout((()=>{emit("end",event),type="start"}),50)}))}))}static#_=this.ctorParameters=()=>[{type:core.ElementRef},{type:zoom_service.T},{type:chart_service.u},{type:core.NgZone}];static#_2=this.propDecorators={config:[{type:core.Input}],axis:[{type:core.Input}],size:[{type:core.Input}],zoomable:[{type:core.HostBinding,args:["class.zoomable"]}],crosshair:[{type:core.HostBinding,args:["class.crosshair"]}],mouseenter:[{type:core.HostListener,args:["mouseenter"]}],mouseleave:[{type:core.HostListener,args:["mouseleave"]}]}};ZoomableDirective=(0,tslib_es6.Cg)([(0,core.Directive)({selector:"[tetaZoomable]",standalone:!0}),(0,tslib_es6.Sn)("design:paramtypes",[core.ElementRef,zoom_service.T,chart_service.u,core.NgZone])],ZoomableDirective);var y_axis_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/y-axis/y-axis.component.scss?ngResource"),y_axis_componentngResource_default=__webpack_require__.n(y_axis_componentngResource);let YAxisComponent=class YAxisComponent{constructor(scaleService){this.scaleService=scaleService,this._alive=!0,this.y=this.scaleService.scales.pipe((0,map.T)((_=>_.y.get(this.axis.index)?.scale)))}ngOnInit(){}ngOnDestroy(){this._alive=!1}ngAfterViewInit(){}getLabelTransform(){return`translate(${this.axis.options.opposite?this.axis.selfSize:-this.axis.selfSize}, ${this.size.height/2}) rotate(-90)`}static#_=this.ctorParameters=()=>[{type:scale_service.e}];static#_2=this.propDecorators={axis:[{type:core.Input}],size:[{type:core.Input}]}};YAxisComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-y-axis]",template:'@if (y | async; as scale) {\n  @for (tick of scale.ticks(); track tick) {\n    <svg:g [attr.text-anchor]="axis.options.opposite ? \'start\' : \'end\'"\n           [attr.transform]="\'translate(0, \'+ scale(tick) +\')\'">\n      <text fill="var(--color-text-70)" dy="0.32em"\n            [attr.x]="axis.options.opposite ? 10 : -9">\n        {{ this.axis.options.tickFormat ? this.axis.options.tickFormat(tick) : this.axis.defaultFormatter()(tick) }}\n      </text>\n      <line stroke="var(--color-text-30)" [attr.x2]="axis.options.opposite ? 6 : -6"></line>\n    </svg:g>\n  }\n  <svg:g class="label-axis font-caption" [attr.transform]="getLabelTransform()">\n    <text [attr.dy]="axis.options.opposite ? \'-4px\' : \'4px\'" text-anchor="middle"\n          [attr.dominant-baseline]="axis.options.opposite ? \'auto\' : \'hanging\'">\n      {{ axis.options.title }}\n    </text>\n  </svg:g>\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe],styles:[y_axis_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[scale_service.e])],YAxisComponent);var plot_band_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/plotband/plot-band.component.scss?ngResource"),plot_band_componentngResource_default=__webpack_require__.n(plot_band_componentngResource);let PlotBandComponent=class PlotBandComponent{click(event){this.emit({target:this.plotBand,event})}contextMenu(event){this.emit({target:this.plotBand,event})}get height(){return this.size.height}get width(){return this.size.width}get from(){return this.scale(this.plotBand.from)}get to(){return this.scale(this.plotBand.to)}get bandSize(){return Math.abs(this.scale(this.plotBand.to)-this.scale(this.plotBand.from))}constructor(chartService,cdr,element){this.chartService=chartService,this.cdr=cdr,this.element=element,this.orientation=axis_orientation.U,this.getTextPosition=()=>{let[min,max]=this.scale.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max;const from=this.plotBand.from instanceof Date?this.plotBand.from.getTime():this.plotBand.from,to=this.plotBand.to instanceof Date?this.plotBand.to.getTime():this.plotBand.to,position=((from<=min?min:from)+(to>=max?max:to))/2;return this.scale(position)}}emit(event){this.chartService.emitPlotband(event)}ngAfterViewInit(){const plotbandElement=src.Ltv(this.element.nativeElement).select(".plotband"),grabElements=src.Ltv(this.element.nativeElement).selectAll(".grabber");this.dragElements=src.$Er().subject((()=>this.axis.orientation===axis_orientation.U.x?{x:plotbandElement.attr("x")}:this.axis.orientation===axis_orientation.U.y?{y:plotbandElement.attr("y")}:null));const drag=this.dragElements.on("start drag end",((event,d)=>{const bandSize=parseFloat(plotbandElement.attr(this.axis.orientation===axis_orientation.U.x?"width":"height"));d.from=this.scale.invert(event[axis_orientation.U[this.axis.orientation]]),d.to=this.scale.invert(event[axis_orientation.U[this.axis.orientation]]+bandSize),this.emit({event,target:d}),this.cdr.detectChanges()}));let grabberKey;this.resizeElements=src.$Er();const resize=this.resizeElements.on("start drag end",((event,d)=>{if("start"===event?.type){const{grabber}=event?.sourceEvent?.target?.dataset;grabberKey=grabber}const min=Math.min(...this.scale.domain()),max=Math.max(...this.scale.domain()),minValue=d.min??min,maxValue=d.max??max;if(d[grabberKey]=this.scale.invert(event[axis_orientation.U[this.axis.orientation]]),"from"===grabberKey){const borderMin=d.from<=minValue;d.from>=d.to&&(d.from=d.to),borderMin&&(d.from=minValue)}if("to"===grabberKey){d.to>=maxValue&&(d.to=maxValue),d.to<=d.from&&(d.to=d.from)}this.emit({event,target:d}),this.cdr.detectChanges()}));plotbandElement.datum(this.plotBand),grabElements.datum(this.plotBand),this.plotBand.draggable&&plotbandElement.call(drag),this.plotBand.resizable&&grabElements.call(resize)}ngOnDestroy(){this.dragElements.on("start drag end",null),this.resizeElements.on("start drag end",null)}getFill(d){return d.style?.plotBand?.patternImage?`url(#${d.style.plotBand?.patternImage})`:d.style.plotBand?.fill}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:core.ElementRef}];static#_2=this.propDecorators={plotBand:[{type:core.Input}],axis:[{type:core.Input}],scale:[{type:core.Input}],size:[{type:core.Input}],click:[{type:core.HostListener,args:["click",["$event"]]}],contextMenu:[{type:core.HostListener,args:["contextmenu",["$event"]]}]}};PlotBandComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-plot-band]",template:"<svg:rect\n  class='plotband' xmlns:svg='http://www.w3.org/1999/html'\n  [class.draggable]='plotBand?.draggable === true'\n  [attr.fill]='getFill(plotBand)'\n  [attr.opacity]='plotBand.style?.plotBand?.opacity'\n  [attr.height]='axis.orientation === orientation.x ? height : bandSize'\n  [attr.width]='axis.orientation === orientation.x ? bandSize : width'\n  [attr.y]='axis.orientation === orientation.y ? (axis.options.inverted === true ? from : to) : null'\n  [attr.x]='axis.orientation === orientation.x ? (axis.options.inverted === true ? to : from) : null'>\n</svg:rect>\n@if (axis.orientation === orientation.x) {\n  <svg:text\n    text-anchor='middle'\n    dominant-baseline='middle'\n    class='label font-caption fill-text-90'\n    [attr.x]='getTextPosition()'\n    [attr.transform]=\"'rotate(-90, '+ getTextPosition() +',' + height / 2 + ')'\"\n    [attr.y]='height / 2'>{{ plotBand.label }}\n  </svg:text>\n}\n@if (axis.orientation === orientation.y) {\n  <svg:text\n    text-anchor='middle'\n    class='label font-caption fill-text-90'\n    dominant-baseline='central'\n    [attr.x]='getTextPosition()'\n    [attr.y]='width / 2'>{{ plotBand.label }}\n  </svg:text>\n}\n@if (plotBand.resizable) {\n  @if (plotBand.showGrabbers) {\n    <svg:line class='display-grabber'\n              [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n              [attr.stroke-width]='plotBand.style?.grabbers?.strokeWidth || 4'\n              [attr.stroke-dasharray]='plotBand.style?.grabbers?.strokeDasharray'\n              [attr.x1]='axis.orientation === orientation.x ? from : 0'\n              [attr.x2]='axis.orientation === orientation.x ? from : width'\n              [attr.data-grabber]=\"'from'\"\n              [attr.y1]='axis.orientation === orientation.x ? 0 : from'\n              [attr.y2]='axis.orientation === orientation.x ? height : from'>\n    </svg:line>\n    <svg:line class='display-grabber'\n              [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n              [attr.stroke-width]='plotBand.style?.grabbers?.strokeWidth || 4'\n              [attr.stroke-dasharray]='plotBand.style?.grabbers?.strokeDasharray'\n              [attr.x1]='axis.orientation === orientation.x ? to : 0'\n              [attr.x2]='axis.orientation === orientation.x ? to : width'\n              [attr.data-grabber]=\"'to'\"\n              [attr.y1]='axis.orientation === orientation.x ? 0 : to'\n              [attr.y2]='axis.orientation === orientation.x ? height : to'>\n    </svg:line>\n  }\n  <svg:line class='grabber'\n            [class.x-grabber]='axis.orientation === orientation.x'\n            [class.y-grabber]='axis.orientation === orientation.y'\n            [class.resizeable]='plotBand?.resizable'\n            [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n            [attr.stroke-width]='8'\n            [style.transform]=\"axis.orientation === orientation.x ? 'translateX(2px)' : 'translateY(2px)'\"\n            [attr.x1]='axis.orientation === orientation.x ? from : 0'\n            [attr.x2]='axis.orientation === orientation.x ? from : width'\n            [attr.data-grabber]=\"'from'\"\n            [attr.y1]='axis.orientation === orientation.x ? 0 : from'\n            [attr.y2]='axis.orientation === orientation.x ? height : from'>\n  </svg:line>\n  <svg:line class='grabber'\n            [class.x-grabber]='axis.orientation === orientation.x'\n            [class.y-grabber]='axis.orientation === orientation.y'\n            [class.resizeable]='plotBand?.resizable'\n            [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n            [attr.stroke-width]='8'\n            [style.transform]=\"axis.orientation === orientation.x ? 'translateX(-2px)' : 'translateY(-2px)'\"\n            [attr.x1]='axis.orientation === orientation.x ? to : 0'\n            [attr.x2]='axis.orientation === orientation.x ? to : width'\n            [attr.data-grabber]=\"'to'\"\n            [attr.y1]='axis.orientation === orientation.x ? 0 : to'\n            [attr.y2]='axis.orientation === orientation.x ? height : to'>\n  </svg:line>\n}\n",standalone:!0,imports:[],changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[plot_band_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,core.ElementRef])],PlotBandComponent);var gridlines_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/gridlines/gridlines.component.scss?ngResource"),gridlines_componentngResource_default=__webpack_require__.n(gridlines_componentngResource);function generateTicks(extremes,count=10){const[min,max]=extremes,tickStep=(max-min)/count;return src.y17(min,max+tickStep,tickStep).filter((step=>step<=max))}let GridlinesComponent=class GridlinesComponent{constructor(svc,chartService){this.svc=svc,this.chartService=chartService,this.config=this.chartService.config,this.tickYValues=this.svc.scales.pipe((0,withLatestFrom.E)(this.config),(0,map.T)((_=>{const[scales,config]=_,ratio=this.size.height/40;return null!=config.gridLines?.y?.ticksCount?generateTicks(scales.y.get(0).scale.domain(),config.gridLines?.y?.ticksCount):scales.y.get(0)?.scale.ticks(ratio)}))),this.tickXValues=this.svc.scales.pipe((0,withLatestFrom.E)(this.config),(0,map.T)((_=>{const[scales,config]=_,ratio=this.size.width/40;return null!=config.gridLines?.x?.ticksCount?generateTicks(scales.x.get(0).originDomain,config.gridLines?.x?.ticksCount):scales.x.get(0)?.scale.ticks(ratio)}))),this.y=this.svc.scales.pipe((0,map.T)((_=>_.y.get(0)?.scale))),this.x=this.svc.scales.pipe((0,map.T)((_=>_.x.get(0)?.scale)))}ngAfterViewInit(){}static#_=this.ctorParameters=()=>[{type:scale_service.e},{type:chart_service.u}];static#_2=this.propDecorators={size:[{type:core.Input}]}};GridlinesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-gridlines]",template:'@if ({\n  xValues: tickXValues | async,\n  yValues: tickYValues | async,\n  x: x | async,\n  y: y | async,\n  config: config | async\n}; as data) {\n  @if (data.y && data.config.gridLines?.showY !== false) {\n    @for (tick of data.yValues; track tick) {\n      <svg:line [attr.x1]="0"\n                [attr.y1]="data.y(tick) || 1"\n                [attr.x2]="size?.width"\n                [attr.y2]="data.y(tick) || 1"></svg:line>\n    }\n  }\n  @if (data.x && data.config.gridLines?.showX !== false) {\n    @for (tick of data.xValues; track tick) {\n      <svg:line [attr.x1]="data.x(tick) || 1"\n                [attr.y1]="0"\n                [attr.x2]="data.x(tick) || 1"\n                [attr.y2]="size?.height"></svg:line>\n    }\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe],styles:[gridlines_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[scale_service.e,chart_service.u])],GridlinesComponent);var series_base_component=__webpack_require__("./projects/chart/src/chart/base/series-base.component.ts");var line_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/line/line-series.component.scss?ngResource"),line_series_componentngResource_default=__webpack_require__.n(line_series_componentngResource),clip_points_direction=__webpack_require__("./projects/chart/src/chart/model/enum/clip-points-direction.ts");let LinearSeriesBase=class LinearSeriesBase extends series_base_component.c{set series(series){this.__series=series,this.markers=this.__series.data?.filter((_=>_?.marker&&void 0!==_?.x&&void 0!==_?.y&&null!==_?.x&&null!==_?.y))}get series(){return this.__series}constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.defaultClipPointsMapping=new Map,this._update=new BehaviorSubject.t(null)}ngOnInit(){this.defaultClipPointsMapping.set(clip_points_direction.$.x,((min,max)=>(point,idx,arr)=>{const bigger=min>max?min:max,smaller=min>max?max:min;return(point.x<=bigger||point.x1<=bigger||arr[idx-1]&&arr[idx-1].x<=bigger||arr[idx-1]&&arr[idx-1].x1<=bigger)&&(point.x>=smaller||point.x1>=smaller||arr[idx+1]&&arr[idx+1].x>=smaller||arr[idx+1]&&arr[idx+1].x1>=smaller)})),this.defaultClipPointsMapping.set(clip_points_direction.$.y,((min,max)=>(point,idx,arr)=>{const bigger=min>max?min:max,smaller=min>max?max:min;return(point.y<=bigger||point.y1<=bigger||arr[idx-1]&&arr[idx-1].y<=bigger||arr[idx-1]&&arr[idx-1].y1<=bigger)&&(point.y>=smaller||point.y1>=smaller||arr[idx+1]&&arr[idx+1].y>=smaller||arr[idx+1]&&arr[idx+1].y1>=smaller)})),this.transform=this.svc.pointerMove.pipe((0,withLatestFrom.E)(this.scaleService.scales),(0,map.T)((data=>{const[event,{x,y}]=data;return this.getTransform(event,x.get(this.series.xAxisIndex).scale,y.get(this.series.yAxisIndex).scale)})),(0,tap.M)((()=>setTimeout((()=>this.cdr.detectChanges()))))),this.path=(0,combineLatest.z)([this.scaleService.scales,this._update]).pipe((0,map.T)((([data])=>{const{x,y}=data;if(this.x=x.get(this.series.xAxisIndex)?.scale,this.y=y.get(this.series.yAxisIndex)?.scale,!this.x||!this.y)return"";const filter=this.defaultClipPointsMapping.get(this.series.clipPointsDirection),line=src.n8j().defined((point=>null!==point.x&&null!==point.y&&void 0!==point.x&&void 0!==point.y&&!isNaN(point.x)&&!isNaN(point.y))).x((point=>this.x(point.x))).y((point=>this.y(point.y)));let filteredData=this.series.data;if(this.series.clipPointsDirection===clip_points_direction.$.x){let[min,max]=this.x.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}if(this.series.clipPointsDirection===clip_points_direction.$.y){let[min,max]=this.y.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}return line(filteredData)})))}ngOnDestroy(){this.svc.setTooltip({point:null,series:this.series})}ngAfterViewInit(){}getTransform(event,scaleX,scaleY){if("mouseleave"===event.type)return null;const mouse=[event?.offsetX,event?.offsetY],tooltipTracking=this.config?.tooltip?.tracking,lineIntersection=(p0_x,p0_y,p1_x,p1_y,p2_x,p2_y,p3_x,p3_y)=>{const rV={};let s1_x,s1_y,s2_x,s2_y,s,t;return s1_x=p1_x-p0_x,s1_y=p1_y-p0_y,s2_x=p3_x-p2_x,s2_y=p3_y-p2_y,s=(-s1_y*(p0_x-p2_x)+s1_x*(p0_y-p2_y))/(-s2_x*s1_y+s1_x*s2_y),t=(s2_x*(p0_y-p2_y)-s2_y*(p0_x-p2_x))/(-s2_x*s1_y+s1_x*s2_y),s>=0&&s<=1&&t>=0&&t<=1&&(rV.x=p0_x+t*s1_x,rV.y=p0_y+t*s1_y),rV};if(tooltipTracking===tooltip_tracking.V.x){const bisect=src.ylB((_=>_.x)).right,pointer=mouse[0];let x0=scaleX.invert(pointer);x0 instanceof Date&&(x0=x0.getTime());const rightId=bisect(this.series.data,x0),intersect=lineIntersection(pointer,scaleY.range()[0],pointer,Number.MAX_SAFE_INTEGER,scaleX(this.series.data[rightId-1]?.x),scaleY(this.series.data[rightId-1]?.y),scaleX(this.series.data[rightId]?.x),scaleY(this.series.data[rightId]?.y)),x=scaleX.invert(intersect.x),y=scaleY.invert(intersect.y);return null==x||isNaN(x)||null==y||isNaN(y)?this.svc.setTooltip({point:null,series:this.series}):this.svc.setTooltip({point:{x:scaleX.invert(intersect.x),y:scaleY.invert(intersect.y)},series:this.series}),{x:intersect.x,y:intersect.y}}if(tooltipTracking===tooltip_tracking.V.y){const bisect=src.ylB((_=>_.y)).right;let y0=scaleY.invert(mouse[1]);y0 instanceof Date&&(y0=y0.getTime());const rightId=bisect(this.series.data,y0),intersect=lineIntersection(scaleX.range()[0],mouse[1],Number.MAX_SAFE_INTEGER,mouse[1],scaleX(this.series.data[rightId-1]?.x),scaleY(this.series.data[rightId-1]?.y),scaleX(this.series.data[rightId]?.x),scaleY(this.series.data[rightId]?.y)),x=scaleX.invert(intersect.x),y=scaleY.invert(intersect.y);return null==x||isNaN(x)||null==y||isNaN(y)?this.svc.setTooltip({point:null,series:this.series}):this.svc.setTooltip({point:{x:scaleX.invert(intersect.x),y:scaleY.invert(intersect.y)},series:this.series}),{x:intersect.x,y:intersect.y}}return null}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}];static#_2=this.propDecorators={series:[{type:core.Input}]}};LinearSeriesBase=(0,tslib_es6.Cg)([(0,core.Component)({template:"",standalone:!0}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],LinearSeriesBase);var drag_point_type=__webpack_require__("./projects/chart/src/chart/model/enum/drag-point-type.ts");let DraggablePointDirective=class DraggablePointDirective{constructor(_elementRef){this._elementRef=_elementRef,this.moveStart=new core.EventEmitter,this.moveProcess=new core.EventEmitter,this.moveEnd=new core.EventEmitter}mouseDown(event){this.tetaDraggablePoint&&(event.stopPropagation(),event.preventDefault(),this.startPosition={x:event.x,y:event.y},this.moveStart.emit(this.startPosition))}mouseUp(event){if(null!==this.startPosition&&void 0!==this.startPosition){let deltaX=event.x-this.startPosition.x,deltaY=event.y-this.startPosition.y;if(this.dragDirection===drag_point_type.D.x&&(deltaY=0),this.dragDirection===drag_point_type.D.y&&(deltaX=0),this.allowDrag&&!this.allowDrag({x:event.x,y:event.y,deltaX,deltaY}))return void(this.startPosition=null);this.transformCache?(this.transformCache.x=this.transformCache.x+deltaX,this.transformCache.y=this.transformCache.y+deltaY):this.transformCache={x:deltaX,y:deltaY},this.moveEnd.emit({x:event.x,y:event.y,deltaX,deltaY})}this.startPosition=null}mouseMove(event){if(this.startPosition){let deltaX=event.x-this.startPosition.x,deltaY=event.y-this.startPosition.y;if(this.transformCache&&(deltaX=this.transformCache.x+deltaX,deltaY=this.transformCache.y+deltaY),this.allowDrag&&!this.allowDrag({x:event.x,y:event.y,deltaX,deltaY}))return;this.dragDirection===drag_point_type.D.x&&(deltaY=0),this.dragDirection===drag_point_type.D.y&&(deltaX=0),this.setTransform(deltaX,deltaY),event.stopPropagation(),event.preventDefault(),this.moveProcess.emit({x:event.x,y:event.y,deltaX,deltaY})}}setTransform(x,y){this._elementRef.nativeElement.style.transform=`translate(${x}px, ${y}px)`}resetTransform(){this.setTransform(0,0),this.transformCache=null}static#_=this.ctorParameters=()=>[{type:core.ElementRef}];static#_2=this.propDecorators={tetaDraggablePoint:[{type:core.Input}],dragDirection:[{type:core.Input}],allowDrag:[{type:core.Input}],moveStart:[{type:core.Output}],moveProcess:[{type:core.Output}],moveEnd:[{type:core.Output}],mouseDown:[{type:core.HostListener,args:["mousedown",["$event"]]},{type:core.HostListener,args:["touchstart",["$event"]]}],mouseUp:[{type:core.HostListener,args:["window:mouseup",["$event"]]},{type:core.HostListener,args:["window:touchend",["$event"]]}],mouseMove:[{type:core.HostListener,args:["window:mousemove",["$event"]]},{type:core.HostListener,args:["window:touchmove",["$event"]]}]}};DraggablePointDirective=(0,tslib_es6.Cg)([(0,core.Directive)({selector:"[tetaDraggablePoint]",exportAs:"tetaDraggablePoint",standalone:!0}),(0,tslib_es6.Sn)("design:paramtypes",[core.ElementRef])],DraggablePointDirective);let LineSeriesComponent=class LineSeriesComponent extends LinearSeriesBase{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.allowDrag=point=>newPoint=>!(null!==point.marker.minX&&void 0!==point.marker.minX&&this.x.invert(this.x(this.start.x)+newPoint.deltaX)<point.marker.minX)&&(!(null!==point.marker.maxX&&void 0!==point.marker.maxX&&this.x.invert(this.x(this.start.x)+newPoint.deltaX)>point.marker.maxX)&&(!(null!==point.marker.minY&&void 0!==point.marker.minY&&this.y.invert(this.y(this.start.y)+newPoint.deltaY)<point.marker.minY)&&!(null!==point.marker.maxY&&void 0!==point.marker.maxY&&this.y.invert(this.y(this.start.y)+newPoint.deltaY)>point.marker.maxY)))}moveStart(event,point){this.start={x:point.x,y:point.y}}moveEnd(event,point){point.x=this.x.invert(this.x(this.start.x)+event.deltaX),point.y=this.y.invert(this.y(this.start.y)+event.deltaY),this._update.next();const emitEvent={type:"end",sourceEvent:event};this.svc.emitPoint({target:{series:this.series,point},event:emitEvent})}moveProcess(event,point){point.x=this.x.invert(this.x(this.start.x)+event.deltaX),point.y=this.y.invert(this.y(this.start.y)+event.deltaY),this._update.next();const emitEvent={type:"drag",sourceEvent:event};this.svc.emitPoint({target:{series:this.series,point},event:emitEvent})}startLabel(event,label){this.labelStart={dx:label.dx,dy:label.dy}}moveLabel(event,label){label.dx=this.labelStart.dx+event.deltaX,label.dy=this.labelStart.dy+event.deltaY}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}]};LineSeriesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"svg:svg[teta-line-series]",template:'<svg:path\n  class="line"\n  [attr.d]="path | async"\n  [attr.stroke]="series.color"\n  [attr.stroke-dasharray]="series.style?.strokeDasharray"\n  [attr.stroke-width]="series.style?.strokeWidth"\n  fill="none">\n</svg:path>\n@if (transform | async; as t) {\n  @if (t?.x != null && t?.y != null) {\n    <svg:circle r="3"\n                [attr.fill]="series.color"\n                [attr.transform]="\'translate(\'+ t.x +\', \'+ t.y +\')\'">\n    </svg:circle>\n  }\n}\n@if (markers; as draggablePoints) {\n  @if (x && y) {\n    @for (point of draggablePoints; track point) {\n      <svg:g\n        [attr.transform]="\'translate(\' + x(point.x) + \',\' + y(point.y) + \')\'">\n        <svg:g [tetaDraggablePoint]="point.marker.draggable"\n               [dragDirection]="point.marker.dragType"\n               [allowDrag]="allowDrag(point)"\n               #dragPoint="tetaDraggablePoint"\n               (moveStart)="moveStart($event, point)"\n               (moveEnd)="moveEnd($event, point);dragPoint.resetTransform();"\n               (moveProcess)="moveProcess($event, point);dragPoint.resetTransform();"\n               [class.draggable-marker]="point?.marker?.draggable">\n          <svg:circle\n            class="marker"\n            [attr.r]="point.marker.style?.radius ?? 5"\n            [attr.fill]="point.marker.style?.fill ?? \'transparent\'"\n            [attr.stroke]="point.marker.style?.stroke ?? \'none\'"\n            [attr.stroke-width]="point.marker.style?.strokeWidth"\n            [attr.stroke-dasharray]="point.marker.style?.strokeDasharray"\n            [attr.cx]="0"\n            [attr.cy]="0">\n          </svg:circle>\n          @if (point.marker.label?.text) {\n            <svg:line\n              [attr.x1]="0"\n              [attr.y1]="0"\n              [attr.x2]="point.marker.label?.dx"\n              [attr.y2]="point.marker.label?.dy"\n              [attr.stroke]="point.marker.label?.style?.stroke ?? \'var(--color-text-90)\'"\n              [attr.stroke-width]="point.marker.label?.style?.strokeWidth ?? 1"\n              [attr.stroke-dasharray]="point.marker.label?.style?.strokeDasharray ?? null">\n            </svg:line>\n            <svg:foreignObject\n              [tetaDraggablePoint]="point.marker.label?.draggable"\n              [dragDirection]="point.marker.label.dragType"\n              #labelPoint="tetaDraggablePoint"\n              (moveStart)="startLabel($event, point.marker.label)"\n              (moveProcess)="moveLabel($event, point.marker.label); labelPoint.resetTransform();"\n              (moveEnd)="labelPoint.resetTransform();"\n              [attr.width]="annotationNode?.offsetWidth ?? 0"\n              [attr.height]="annotationNode?.offsetHeight ?? 0"\n              [attr.x]="point.marker.label?.dx"\n              [attr.y]="point.marker.label?.dy"\n              class="position-absolute">\n              <div\n                #annotationNode\n                class="shadow-2 padding-2"\n                [style.color]="\'var(--color-text-90)\'"\n                [style.background-color]="\'var(--color-global-bgcard)\'"\n                [style.cursor]="\'move\'"\n                style="border-radius: 2px; display: inline-block;">\n                {{ point.marker.label?.text }}\n              </div>\n            </svg:foreignObject>\n          }\n        </svg:g>\n      </svg:g>\n    }\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe,DraggablePointDirective],styles:[line_series_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],LineSeriesComponent);var series_type=__webpack_require__("./projects/chart/src/chart/model/enum/series-type.ts");var bar_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/bar/bar-series.component.scss?ngResource"),bar_series_componentngResource_default=__webpack_require__.n(bar_series_componentngResource);let BarSeriesComponent=class BarSeriesComponent extends series_base_component.c{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.Math=Math}ngOnInit(){this.barSeriesCount=this.svc.config.pipe((0,map.T)((_=>_.series.filter((_=>_.type===series_type.O.bar&&_.xAxisIndex===this.series.xAxisIndex)).length))),this.x1=this.scaleService.scales.pipe((0,map.T)((_=>{const x=_.x.get(this.series.xAxisIndex)?.scale,range=x.range(),domain=this.series.data.map((_=>_.x));return src.WH().range([0,range[1]]).domain(domain).padding(.1)}))),this.x=this.scaleService.scales.pipe((0,map.T)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.T)((_=>_.y.get(this.series.yAxisIndex)?.scale)))}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}ngOnChanges(changes){}isNumber(value){return"number"==typeof value}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}]};BarSeriesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"svg:svg[teta-bar-series]",template:'@if ({\n  x: x | async,\n  x1: x1 | async,\n  y: y | async,\n  barSeriesCount: barSeriesCount | async\n}; as data) {\n  @if (data.x && data.y) {\n    @if (data.barSeriesCount > 1) {\n      @for (point of series.data; track point; ) {\n        <svg:rect\n          (mouseenter)="mouseenter(point)"\n          (mouseleave)="mouseleave(point)"\n          [attr.x]="data.x(point.x) + ((isNumber(series.id) ? series.id : 0) * data.x1.bandwidth() / data.barSeriesCount)"\n          [attr.y]="point.y > 0 ? data.y(point.y) : data.y(0)"\n          [attr.width]="data.x1.bandwidth() / data.barSeriesCount"\n          [attr.height]="Math.abs(data.y(point.y) - data.y(0))"\n          [attr.fill]="series.color"\n        ></svg:rect>\n      }\n    }\n    @if (data.barSeriesCount === 1) {\n      @for (point of series.data; track point; ) {\n        <svg:rect\n          (mouseenter)="mouseenter(point)"\n          (mouseleave)="mouseleave(point)"\n          [attr.x]="data.x(point.x)"\n          [attr.y]="point.y > 0 ? data.y(point.y) : data.y(0)"\n          [attr.width]="data.x1.bandwidth()"\n          [attr.height]="Math.abs(data.y(point.y) - data.y(0))"\n          [attr.fill]="point.color ?? series.color"\n        ></svg:rect>\n      }\n    }\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe],styles:[bar_series_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],BarSeriesComponent);var scatter_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/scatter-series/scatter-series.component.scss?ngResource"),scatter_series_componentngResource_default=__webpack_require__.n(scatter_series_componentngResource);let ScatterSeriesComponent=class ScatterSeriesComponent extends series_base_component.c{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.T)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.T)((_=>_.y.get(this.series.yAxisIndex)?.scale)))}ngAfterViewInit(){}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}]};ScatterSeriesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"svg:svg[teta-scatter-series]",template:'@if ({\n  y: y | async,\n  x: x | async\n}; as scales) {\n  @if (scales.x && scales.y) {\n    @for (point of series.data; track point) {\n      <svg:circle\n        class="line"\n        (mouseenter)="mouseenter(point)"\n        (mouseleave)="mouseleave(point)"\n        [attr.cx]="scales.x(point.x)"\n        [attr.cy]="scales.y(point.y)"\n        [attr.r]="series.style?.radius ?? 1"\n        [attr.stroke]="point.color ?? series.color"\n        [attr.fill]="point.color ?? series.color"\n        [attr.stroke-width]="series.style?.strokeWidth">\n      </svg:circle>\n    }\n  }\n}\n',standalone:!0,imports:[common.AsyncPipe],changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[scatter_series_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],ScatterSeriesComponent);var block_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/block-series/block-series.component.scss?ngResource"),block_series_componentngResource_default=__webpack_require__.n(block_series_componentngResource),fill_type=__webpack_require__("./projects/chart/src/chart/model/enum/fill-type.ts");let BlockSeriesComponent=class BlockSeriesComponent extends series_base_component.c{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillType=fill_type.k,this.Math=Math,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.T)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.T)((_=>_.y.get(this.series.yAxisIndex)?.scale))),this.displayPoints=this.y.pipe((0,filter.p)((y=>y)),(0,map.T)((y=>this.series.data.filter(((point,index,arr)=>{const[min,max]=y.domain();return(point.y>=min||point.y1>=min||arr[index+1]?.y>=min||arr[index+1]?.y1>=min)&&(point.y<=max||point.y1<=max||arr[index-1]?.y<=max||arr[index-1]?.y1<=max)})))))}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}]};BlockSeriesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"svg:svg[teta-block-series]",template:'@if ({\n  y: y | async,\n  x: x | async,\n  points: displayPoints | async\n}; as data) {\n  @if (series?.fillType === fillType.gradient) {\n    <svg:defs>\n      <svg:linearGradient [id]="\'gradient-fill-\' + id" gradientUnits="userSpaceOnUse"\n                          x1="0%"\n                          [attr.y1]="config?.inverted ? \'0%\' : \'100%\'"\n                          [attr.x2]="config?.inverted ? \'100%\' : \'0%\'"\n                          y2="0%">\n        <svg:stop offset="0%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0"></svg:stop>\n        <svg:stop offset="5%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.1"></svg:stop>\n        <svg:stop offset="20%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.2"></svg:stop>\n        <svg:stop offset="60%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.5"></svg:stop>\n        <svg:stop offset="100%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.9"></svg:stop>\n      </svg:linearGradient>\n    </svg:defs>\n  }\n  @if (data.x && data.y) {\n    @for (point of data.points; track point) {\n      <svg:g (mouseenter)="mouseenter(point)"\n             (mouseleave)="mouseleave(point)">\n        <svg:rect\n          x="0"\n          [attr.y]="data.y(point.y)"\n          [attr.height]="Math.abs(data.y(point.y1) - data.y(point.y))"\n          [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.style?.fill ?? series.color"\n          [attr.fill-opacity]="series.style?.fillOpacity"\n          width="100%">\n        </svg:rect>\n        @if (point.text && data.y(point.y1) - data.y(point.y) > 8) {\n          <svg:text x="50%"\n                    [attr.y]="(data.y(point.y1) + data.y(point.y)) / 2"\n                    alignment-baseline="middle"\n                    text-anchor="middle">{{ point.text }}\n          </svg:text>\n        }\n        <svg:line x1="0" x2="100%" [attr.y1]="data.y(point.y)" [attr.y2]="data.y(point.y)"\n                  [attr.stroke]="point.iconId ? \'var(--color-text-10)\' : point.color ?? series.style?.stroke ?? series.color"></svg:line>\n        <svg:line x1="0" x2="100%" [attr.y1]="data.y(point.y1)" [attr.y2]="data.y(point.y1)"\n                  [attr.stroke]="point.iconId ? \'var(--color-text-10)\' : point.color ?? series.style?.stroke ?? series.color"></svg:line>\n      </svg:g>\n    }\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe],styles:[block_series_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],BlockSeriesComponent);var block_area_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/block-area-series/block-area-series.component.scss?ngResource"),block_area_series_componentngResource_default=__webpack_require__.n(block_area_series_componentngResource);let BlockAreaSeriesComponent=class BlockAreaSeriesComponent extends series_base_component.c{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillType=fill_type.k,this.Math=Math,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.T)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.T)((_=>_.y.get(this.series.yAxisIndex)?.scale))),this.displayPoints=this.y.pipe((0,filter.p)((y=>y)),(0,map.T)((y=>this.series.data.filter(((point,index,arr)=>{const[min,max]=y.domain();return(point.y>=min||point.y1>=min||arr[index+1]?.y>=min||arr[index+1]?.y1>=min)&&(point.y<=max||point.y1<=max||arr[index-1]?.y<=max||arr[index-1]?.y1<=max)})))))}ngAfterViewInit(){}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}]};BlockAreaSeriesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"svg:svg[teta-block-area-series]",template:'@if ({\n  y: y | async,\n  x: x | async,\n  points: displayPoints | async\n}; as data) {\n  @if (series?.fillType === fillType.gradient) {\n    <svg:defs>\n      <svg:linearGradient [id]="\'gradient-fill-\' + id"\n                          gradientUnits="userSpaceOnUse"\n                          x1="0%"\n                          [attr.y1]="config?.inverted ? \'0%\' : \'100%\'"\n                          [attr.x2]="config?.inverted ? \'100%\' : \'0%\'"\n                          y2="0%">\n        <svg:stop offset="0%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0"></svg:stop>\n        <svg:stop offset="5%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.1"></svg:stop>\n        <svg:stop offset="20%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.2"></svg:stop>\n        <svg:stop offset="60%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.5"></svg:stop>\n        <svg:stop offset="100%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.9"></svg:stop>\n      </svg:linearGradient>\n    </svg:defs>\n  }\n  @if (data.x && data.y) {\n    @for (point of data.points; track point) {\n      <svg:g (mouseenter)="mouseenter(point)"\n             (mouseleave)="mouseleave(point)">\n        @if (!!config.inverted) {\n          <svg:rect\n            [attr.x]="data.x(0) < data.x(point.x) ? data.x(0) : data.x(point.x)"\n            [attr.y]="data.y(point.y)"\n            [attr.height]="Math.abs(data.y(point.y1) - data.y(point.y))"\n            [attr.width]="data.x(0) < data.x(point.x) ? data.x(point.x) - data.x(0) : data.x(0) - data.x(point.x)"\n            [attr.stroke]="point.iconId ? \'\' : point.color ?? series.style?.stroke ?? series.color"\n            [attr.stroke-dasharray]="series.style?.strokeDasharray"\n            [attr.stroke-width]="series.style?.strokeWidth"\n            [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.style?.fill ?? series.color"\n            [attr.fill-opacity]="series.style?.fillOpacity">\n          </svg:rect>\n        } @else {\n          <svg:rect\n            [attr.x]="data.x(point.x)"\n            [attr.y]="data.y(0)"\n            [attr.height]="Math.abs(data.y(0) - data.y(point.y))"\n            [attr.width]="data.x(point.x1) - data.x(point.x)"\n            [attr.stroke]="point.iconId ? \'\' : point.color ?? series.color"\n            [attr.stroke-dasharray]="series.style?.strokeDasharray"\n            [attr.stroke-width]="series.style?.strokeWidth"\n            [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.color"\n            [attr.fill-opacity]="series.style?.fillOpacity">\n          </svg:rect>\n        }\n        @if (point.text) {\n          <svg:text x="50%"\n                    fill="var(--color-text-50)"\n                    [attr.y]="(data.y(point.y1) + data.y(point.y)) / 2"\n                    alignment-baseline="middle"\n                    text-anchor="middle">{{ point.text }}\n          </svg:text>\n        }\n      </svg:g>\n    }\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[common.AsyncPipe],styles:[block_area_series_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],BlockAreaSeriesComponent);var area_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/area-series/area-series.component.scss?ngResource"),area_series_componentngResource_default=__webpack_require__.n(area_series_componentngResource);let AreaSeriesComponent=class AreaSeriesComponent extends LinearSeriesBase{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillDirection=fill_type.F,this.fillType=fill_type.k,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){super.ngOnInit(),this.areaPath=this.scaleService.scales.pipe((0,map.T)((data=>{const{x,y}=data;if(this.x=x.get(this.series.xAxisIndex)?.scale,this.y=y.get(this.series.yAxisIndex)?.scale,!this.x||!this.y)return"";const area=src.Wcw().defined((point=>null!==point.x&&null!==point.y&&!isNaN(point.x)&&!isNaN(point.y)));area.x1((_=>null!==_.x1&&void 0!==_.x1?this.x(_.x1):this.x(0))).x0((_=>this.x(_.x))).y((_=>this.y(_.y)));const filter=this.defaultClipPointsMapping.get(this.series.clipPointsDirection);let filteredData=this.series.data;if(this.series.clipPointsDirection===clip_points_direction.$.x){let[min,max]=this.x.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}if(this.series.clipPointsDirection===clip_points_direction.$.y){let[min,max]=this.y.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}return area(filteredData)})))}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:core.ChangeDetectorRef},{type:scale_service.e},{type:zoom_service.T},{type:core.ElementRef}]};AreaSeriesComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"svg:svg[teta-area-series]",template:'@if (series?.fillType === fillType.gradient) {\n  <svg:defs>\n    <svg:linearGradient [id]="\'gradient-fill-\' + id" gradientUnits="userSpaceOnUse"\n                        x1="0%"\n                        [attr.y1]="config?.inverted || series?.fillDirection === fillDirection.y ? \'0%\' : \'100%\'"\n                        [attr.x2]="config?.inverted || series?.fillDirection === fillDirection.y ? \'100%\' : \'0%\'"\n                        y2="0%">\n      <svg:stop offset="0%" [attr.stop-color]="series.color" stop-opacity="0"></svg:stop>\n      <svg:stop offset="5%" [attr.stop-color]="series.color" stop-opacity="0.1"></svg:stop>\n      <svg:stop offset="20%" [attr.stop-color]="series.color" stop-opacity="0.2"></svg:stop>\n      <svg:stop offset="60%" [attr.stop-color]="series.color" stop-opacity="0.5"></svg:stop>\n      <svg:stop offset="100%" [attr.stop-color]="series.color" stop-opacity="0.8"></svg:stop>\n    </svg:linearGradient>\n  </svg:defs>\n}\n<svg:path\n  class="area"\n  [attr.d]="areaPath | async"\n  [attr.stroke-width]="0"\n  [attr.fill-opacity]="series.style?.fillOpacity"\n  [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : series.style?.fill ?? series.color">\n</svg:path>\n<svg:path\n  class="area"\n  fill="none"\n  [attr.d]="path | async"\n  [attr.stroke]="series.color"\n  [attr.stroke-dasharray]="series.style?.strokeDasharray"\n  [attr.stroke-width]="series.style?.strokeWidth">\n</svg:path>\n@if (transform | async; as t) {\n  @if (t?.x != null && t?.y != null) {\n    <svg:circle\n      r="3"\n      [attr.fill]="series.color"\n      [attr.transform]="\'translate(\'+ t.x +\', \'+ t.y +\')\'">\n    </svg:circle>\n  }\n}\n@if (markers; as draggablePoints) {\n  @for (point of draggablePoints; track point; ) {\n    <svg:circle\n      class="marker"\n      [class.draggable-marker]="point?.marker?.draggable"\n      [attr.r]="point.marker.style?.radius ?? 5"\n      [attr.fill]="point.marker.style?.fill ?? \'transparent\'"\n      [attr.stroke]="point.marker.style?.stroke ?? \'none\'"\n      [attr.stroke-width]="point.marker.style?.strokeWidth"\n      [attr.stroke-dasharray]="point.marker.style?.strokeDasharray"\n      [attr.cx]="x(point.x)"\n      [attr.cy]="y(point.y)">\n    </svg:circle>\n  }\n}\n\n\n\n',standalone:!0,imports:[common.AsyncPipe],changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[area_series_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,core.ChangeDetectorRef,scale_service.e,zoom_service.T,core.ElementRef])],AreaSeriesComponent);const defaultSeriesTypeMapping=(new Map).set(series_type.O.line,LineSeriesComponent).set(series_type.O.bar,BarSeriesComponent).set(series_type.O.scatter,ScatterSeriesComponent).set(series_type.O.block,BlockSeriesComponent).set(series_type.O.area,AreaSeriesComponent).set(series_type.O.blockArea,BlockAreaSeriesComponent);let SeriesHostComponent=class SeriesHostComponent{constructor(viewContainerRef){this.viewContainerRef=viewContainerRef,this._init=!1}ngOnInit(){series_base_component.c.isPrototypeOf(this.series.component)||(this.series.component=defaultSeriesTypeMapping.get(this.series.type)||LineSeriesComponent),this._componentRef=this.viewContainerRef.createComponent(this.series.component),this._componentRef.instance.config=this.config,this._componentRef.instance.series=this.series,this._init=!0}ngOnDestroy(){this._componentRef.destroy()}ngOnChanges(changes){this._init&&(changes.hasOwnProperty("series")||changes.hasOwnProperty("config"))&&(this._componentRef.instance.config=this.config,this._componentRef.instance.series=this.series,this._componentRef.injector.get(core.ChangeDetectorRef).detectChanges())}static#_=this.ctorParameters=()=>[{type:core.ViewContainerRef}];static#_2=this.propDecorators={config:[{type:core.Input}],series:[{type:core.Input}]}};SeriesHostComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-series-host]",template:"",standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush}),(0,tslib_es6.Sn)("design:paramtypes",[core.ViewContainerRef])],SeriesHostComponent);var plotline_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/plotline/plotline.component.scss?ngResource"),plotline_componentngResource_default=__webpack_require__.n(plotline_componentngResource);let PlotlineComponent=class PlotlineComponent{constructor(cdr,zoomService,scaleService,chartService,element){this.cdr=cdr,this.zoomService=zoomService,this.scaleService=scaleService,this.chartService=chartService,this.element=element,this.orientation=axis_orientation.U}ngOnInit(){this._domain=this.scale.domain();const plotlineElement=src.Ltv(this.element.nativeElement).select(".plotline"),grabElement=src.Ltv(this.element.nativeElement).selectAll(".grabber");this.dragElements=src.$Er().subject((()=>this.axis.orientation===axis_orientation.U.y?{y:plotlineElement.attr("y1")}:this.axis.orientation===axis_orientation.U.x?{x:plotlineElement.attr("x1")}:null));const drag=this.dragElements.on("start drag end",((event,d)=>{d.value=this.scale.invert(event[axis_orientation.U[this.axis.orientation]]),null!==d.max&&void 0!==d.max&&d.value>=d.max&&(d.value=d.max),null!==d.min&&void 0!==d.min&&d.value<=d.min&&(d.value=d.min),this.emit({event,target:d}),this.cdr.detectChanges()}));plotlineElement.datum(this.plotLine),grabElement.datum(this.plotLine),this.plotLine.draggable&&grabElement.call(drag)}ngOnDestroy(){this.dragElements.on("start drag end",null)}emit(event){this.chartService.emitPlotline(event)}get value(){return this.scale(this.plotLine.value)}get height(){return this.size.height}get width(){return this.size.width}static#_=this.ctorParameters=()=>[{type:core.ChangeDetectorRef},{type:zoom_service.T},{type:scale_service.e},{type:chart_service.u},{type:core.ElementRef}];static#_2=this.propDecorators={plotLine:[{type:core.Input}],size:[{type:core.Input}],axis:[{type:core.Input}],scale:[{type:core.Input}]}};PlotlineComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-plot-line]",template:'<svg:line class="plotline"\n          [attr.stroke]="plotLine.style?.stroke || \'red\'"\n          [attr.stroke-width]="plotLine.style?.strokeWidth || 4"\n          [attr.stroke-dasharray]="plotLine.style?.strokeDasharray"\n          [attr.x1]="axis.orientation === orientation.x ? value : 0"\n          [attr.x2]="axis.orientation === orientation.x ? value : width"\n          [attr.y1]="axis.orientation === orientation.x ? 0 : value"\n          [attr.y2]="axis.orientation === orientation.x ? height : value">\n</svg:line>\n\n\n@if (axis.orientation === orientation.x) {\n  <svg:text\n    text-anchor="middle"\n    dominant-baseline="central"\n    class="label font-title-2 fill-text-70"\n    [attr.x]="value"\n    dy="-2em"\n    [attr.transform]="\'rotate(-90, \'+ value +\',\' + height / 2 + \')\'"\n    [attr.y]="height / 2">{{ plotLine.label }}\n  </svg:text>\n}\n\n@if (axis.orientation === orientation.y) {\n  <svg:text\n    text-anchor="middle"\n    class="label font-title-2 fill-text-70"\n    dominant-baseline="central"\n    [attr.x]="value"\n    [attr.y]="width / 2">{{ plotLine.label }}\n  </svg:text>\n}\n<svg:line class="grabber"\n          [class.x-grabber]="axis.orientation === orientation.x"\n          [class.y-grabber]="axis.orientation === orientation.y"\n          [attr.stroke]="\'red\'"\n          [attr.stroke-width]="8"\n          opacity="0"\n          [attr.x1]="axis.orientation === orientation.x ? value : 0"\n          [attr.x2]="axis.orientation === orientation.x ? value : width"\n          [attr.y1]="axis.orientation === orientation.x ? 0 : value"\n          [attr.y2]="axis.orientation === orientation.x ? height : value">\n</svg:line>\n',standalone:!0,imports:[],changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[plotline_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[core.ChangeDetectorRef,zoom_service.T,scale_service.e,chart_service.u,core.ElementRef])],PlotlineComponent);var asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");var annotation_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/annotation/annotation.component.scss?ngResource"),annotation_componentngResource_default=__webpack_require__.n(annotation_componentngResource),lastValueFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js"),take=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/take.js");let AnnotationComponent=class AnnotationComponent{set annotation(annotation){this._annotation=annotation}get annotation(){return this._annotation}set node(node){this._node=node,this.init(),this.cdr.detectChanges()}get node(){return this._node}constructor(scaleService,cdr,chartService){this.scaleService=scaleService,this.cdr=cdr,this.chartService=chartService,this.x=this.scaleService.scales.pipe((0,map.T)((_=>_.x.get(this.annotation.xAxisIndex??0)?.scale))),this.y=this.scaleService.scales.pipe((0,map.T)((_=>_.y.get(this.annotation.yAxisIndex??0)?.scale))),this.drag=src.$Er()}click(event){this.chartService.emitAnnotation({event,target:this.annotation})}contextMenu(event){this.chartService.emitAnnotation({event,target:this.annotation})}ngOnDestroy(){this.drag.on("drag end",null)}init(){var _this=this;src.Ltv(this.node.nativeElement).datum(this.annotation);const nodeRect=this.node.nativeElement.getBoundingClientRect();this.annotation.draggable&&(this.drag.on("drag end",function(){var _ref=(0,asyncToGenerator.A)((function*(event,d){const x=yield(0,lastValueFrom.s)(_this.x.pipe((0,take.s)(1))),y=yield(0,lastValueFrom.s)(_this.y.pipe((0,take.s)(1)));d.dx+=event.dx,d.dy+=event.dy,d.dx+x(d.point.x)-10<=0&&(d.dx=10-x(d.point.x)),d.dx+x(d.point.x)+nodeRect.width-10>=_this.visibleRect.width&&(d.dx=_this.visibleRect.width-x(d.point.x)-nodeRect.width+10),d.dy+y(d.point.y)-10<=0&&(d.dy=10-y(d.point.y)),d.dy+y(d.point.y)+nodeRect.height-10>=_this.visibleRect.height&&(d.dy=Math.abs(y(d.point.y)-_this.visibleRect.height)-nodeRect.height+10),_this.cdr.detectChanges(),_this.chartService.emitMoveAnnotation({event,target:d})}));return function(_x,_x2){return _ref.apply(this,arguments)}}()),src.Ltv(this.node.nativeElement).call(this.drag))}static#_=this.ctorParameters=()=>[{type:scale_service.e},{type:core.ChangeDetectorRef},{type:chart_service.u}];static#_2=this.propDecorators={visibleRect:[{type:core.Input}],annotation:[{type:core.Input}],node:[{type:core.ViewChild,args:["annotationNode",{static:!1}]}],click:[{type:core.HostListener,args:["click",["$event"]]}],contextMenu:[{type:core.HostListener,args:["contextmenu",["$event"]]}]}};AnnotationComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-annotation]",template:'@if ({\n  x: x | async,\n  y: y | async\n}; as data) {\n  @if (data.x && data.y) {\n    <svg:circle\n      [attr.r]="annotation.style?.radius ?? 5"\n      [attr.cx]="data.x(annotation.point.x)"\n      [attr.fill]="annotation?.style?.fill ?? \'var(--color-text-90)\'"\n      [attr.cy]="data.y(annotation.point.y)">\n    </svg:circle>\n    <svg:line\n      [attr.x1]="data.x(annotation.point.x)"\n      [attr.y1]="data.y(annotation.point.y)"\n      [attr.x2]="data.x(annotation.point.x) + (annotation.dx ?? 0)"\n      [attr.y2]="data.y(annotation.point.y) + (annotation.dy ?? 0)"\n      [attr.stroke]="annotation.style?.stroke ?? \'var(--color-text-90)\'"\n      [attr.stroke-width]="annotation.style?.strokeWidth ?? 1"\n      [attr.stroke-dasharray]="annotation.style?.strokeDasharray ?? null"\n    >\n    </svg:line>\n    <svg:foreignObject\n      class="position-absolute"\n      [attr.width]="node?.nativeElement.offsetWidth ?? 0"\n      [attr.height]="node?.nativeElement.offsetHeight ?? 0"\n      [attr.x]="data.x(annotation.point.x) + (annotation.dx ?? 0) - 10"\n      [attr.y]="data.y(annotation.point.y) + (annotation.dy ?? 0) - 10">\n      <div\n        #annotationNode\n        [style.background-color]="annotation.style?.fill ?? \'var(--color-global-bgmain)\'"\n        [style.cursor]="annotation?.draggable ? \'move\' : \'default\'"\n        [className]="\'padding-h-2 \' + annotation.className ?? \'\'"\n        style="border-radius: 2px; display: inline-block;">\n        @if (annotation.template) {\n          <ng-container *ngTemplateOutlet="annotation.template;context: {$implicit: annotation}"></ng-container>\n        } @else {\n          {{ annotation.note?.label }}\n        }\n      </div>\n    </svg:foreignObject>\n  }\n}\n',standalone:!0,imports:[common.NgTemplateOutlet,common.AsyncPipe],changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[annotation_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[scale_service.e,core.ChangeDetectorRef,chart_service.u])],AnnotationComponent);var crosshair_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/crosshair/crosshair.component.scss?ngResource"),crosshair_componentngResource_default=__webpack_require__.n(crosshair_componentngResource);let CrosshairComponent=class CrosshairComponent{constructor(scaleService,chartService,cdr){this.scaleService=scaleService,this.chartService=chartService,this.cdr=cdr}ngOnInit(){this.transform=this.chartService.pointerMove.pipe((0,map.T)((event=>({x:"mouseleave"===event.type?-9999:event.offsetX,y:"mouseleave"===event.type?-9999:event.offsetY}))),(0,tap.M)((()=>{setTimeout((()=>{this.cdr.detectChanges()}))})))}static#_=this.ctorParameters=()=>[{type:scale_service.e},{type:chart_service.u},{type:core.ChangeDetectorRef}];static#_2=this.propDecorators={size:[{type:core.Input}]}};CrosshairComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"[teta-crosshair]",template:'@if (transform | async; as t) {\n  <svg:line [attr.x1]="t.x" y1="0" [attr.x2]="t.x" [attr.y2]="size.height" stroke="var(--color-text-90)"\n            stroke-width="0.5"></svg:line>\n  <svg:line x1="0" [attr.y1]="t.y" [attr.x2]="size.width" [attr.y2]="t.y" stroke="var(--color-text-90)"\n            stroke-width="0.5"></svg:line>\n}\n',standalone:!0,imports:[common.AsyncPipe],styles:[crosshair_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[scale_service.e,chart_service.u,core.ChangeDetectorRef])],CrosshairComponent);let BrushableDirective=class BrushableDirective{constructor(brushService,chartService,element,zone){this.brushService=brushService,this.chartService=chartService,this.element=element,this.zone=zone,this.brushMap=(new Map).set(brush_type.p.x,src.n55()).set(brush_type.p.y,src.g2B()),this._alive=!0,this._container=src.Ltv(this.element.nativeElement)}ngOnInit(){this.brushService.brushDomain.pipe((0,takeWhile.v)((()=>this._alive)),(0,filter.p)((brush=>brush.chartId!==this.config.id))).subscribe((brush=>{this._container.call(this.brush.move,[Math.floor(brush.selection[0]),Math.floor(brush.selection[1])].map(this.axis.scale))}))}ngOnDestroy(){this._alive=!1}ngAfterViewInit(){if(this.config?.brush?.enable){const brushMessage=new i_broadcast_message.S({chartId:this.config.id,selection:[this.config?.brush?.from,this.config?.brush?.to],mode:"init"});this.brushService.setBrush(brushMessage)}}ngOnChanges(changes){changes.hasOwnProperty("config")&&this.clearPreviousSelection(),this.config?.brush?.enable&&this.applyBrush(this.config,this.axis.scale)}applyBrush(config,brushScale){this.brush?.on("start brush end",null),config.brush?.enable&&(this.brush=this.brushMap.get(config?.brush?.type??brush_type.p.x),this.brush.on("start brush end",(_=>{if(_.sourceEvent){if(!_.selection)return;const[from,to]=_.selection;if(to-from==0){const selection=this.selection?.map(brushScale)??[config.brush?.from,config.brush?.to].map(brushScale),halfBrushHeight=(selection[1]-selection[0])/2,invertedSelection=[from-halfBrushHeight,to+halfBrushHeight].map(brushScale.invert);return invertedSelection[1]-invertedSelection[0]>config.brush?.max?void this._container.call(this.brush.move,[Math.floor(invertedSelection[0]),Math.floor(invertedSelection[0]+config.brush?.max)].map(brushScale)):invertedSelection[1]-invertedSelection[0]<config.brush?.min?void this._container.call(this.brush.move,[Math.floor(invertedSelection[0]),Math.ceil(invertedSelection[0]+config.brush?.min)].map(brushScale)):void this._container.call(this.brush.move,[from-halfBrushHeight,to+halfBrushHeight])}if(brushScale.invert(to)-brushScale.invert(from)>config.brush?.max)return void this._container.call(this.brush.move,this.selection?[this.selection[0],this.selection[0]+config.brush?.max].map(brushScale):[config.brush?.from,config.brush?.to].map(brushScale));if(brushScale.invert(to)-brushScale.invert(from)<config.brush?.min)return void this._container.call(this.brush.move,this.selection?[this.selection[0],this.selection[0]+config.brush?.min].map(brushScale):[config.brush?.from,config.brush?.to].map(brushScale));_.sourceEvent instanceof MouseEvent&&(this.selection=_.selection.map(brushScale.invert));const brushMessage=new i_broadcast_message.S({chartId:this.config.id,selection:[brushScale.invert(from),brushScale.invert(to)],mode:_.mode});this.brushService.setBrush(brushMessage)}})),this.zone.runOutsideAngular((()=>{setTimeout((()=>{this._container.call(this.brush);let domain=brushScale.domain();config?.brush?.from&&(domain[0]=config.brush.from),config?.brush?.to&&(domain[1]=config.brush.to),this._container.call(this.brush.move,this.selection?this.selection.map(brushScale):domain.map(brushScale),{})}),0)})))}clearPreviousSelection(){this.selection=null}static#_=this.ctorParameters=()=>[{type:BrushService},{type:chart_service.u},{type:core.ElementRef},{type:core.NgZone}];static#_2=this.propDecorators={config:[{type:core.Input}],axis:[{type:core.Input}]}};BrushableDirective=(0,tslib_es6.Cg)([(0,core.Directive)({selector:"[tetaBrushable]",standalone:!0}),(0,tslib_es6.Sn)("design:paramtypes",[BrushService,chart_service.u,core.ElementRef,core.NgZone])],BrushableDirective);var internal_Observable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js");function tetaZoneFull(ngZone){return source=>new internal_Observable.c((subscriber=>source.subscribe({next:value=>ngZone.run((()=>subscriber.next(value))),error:error=>ngZone.run((()=>subscriber.error(error))),complete:()=>ngZone.run((()=>subscriber.complete()))})))}let ChartContainerComponent=class ChartContainerComponent{constructor(_svc,_scaleService,_elementRef,_zone){this._svc=_svc,this._scaleService=_scaleService,this._elementRef=_elementRef,this._zone=_zone,this.zoomType=zoom_type.C,this.filterPositionMap=(new Map).set(!0,(axis=>_=>_.options.opposite&&_.options.visible&&axis.index<=_.index)).set(!1,(axis=>_=>!0!==_.options.opposite&&_.options.visible&&_.index<=axis.index)),this.sumSize=(acc,curr)=>acc+curr.selfSize,this.config=this._svc.config,this.size=this._svc.size,this.scales=this._scaleService.scales.pipe((0,observeOn.Q)(animationFrame.X),tetaZoneFull(this._zone),(0,shareReplay.t)({bufferSize:1,refCount:!0})),this.plotBands=(0,combineLatest.z)([this.config,this.scales]).pipe((0,map.T)((([config,scales])=>{const bands=[];return config.xAxis?.forEach(((axis,index)=>{axis.plotBands?.forEach((band=>{bands.push({plotBand:band,axis:scales.x.get(index)})}))})),config.yAxis?.forEach(((axis,index)=>{axis.plotBands?.forEach((band=>{bands.push({plotBand:band,axis:scales.y.get(index)})}))})),bands.sort(((a,b)=>a.plotBand.order-b.plotBand.order))}))),this.brushScale=this._scaleService.scales.pipe((0,withLatestFrom.E)(this.config),(0,map.T)((data=>{const[{x,y},config]=data;return config.brush?.type===brush_type.p.x||config?.zoom?.type===zoom_type.C.x?x.get(0)?.scale:y.get(0)?.scale})),(0,shareReplay.t)({bufferSize:1,refCount:!0})),this.visibleRect=(0,combineLatest.z)([this.size,this.scales,this.config]).pipe((0,map.T)((data=>{const[size,{x,y},config]=data,yAxesArray=Array.from(y.values()),xAxesArray=Array.from(x.values()),left=yAxesArray.filter((_=>!0!==_.options.opposite&&_.options.visible)).reduce(this.sumSize,0),right=yAxesArray.filter((_=>_.options.opposite&&_.options.visible)).reduce(this.sumSize,0),bottom=xAxesArray.filter((_=>!0!==_.options.opposite&&_.options.visible)).reduce(this.sumSize,0),top=xAxesArray.filter((_=>_.options.opposite&&_.options.visible)).reduce(this.sumSize,0);return{x:left+config.bounds?.left,y:top+config.bounds?.top,width:size.width-left-right-config.bounds?.left-config.bounds?.right,height:size.height-top-bottom-config.bounds?.top-config.bounds?.bottom}})),tetaZoneFull(this._zone),(0,shareReplay.t)({bufferSize:1,refCount:!0}))}ngAfterViewInit(){this._observer=new ResizeObserver((entries=>{requestAnimationFrame((()=>{!Array.isArray(entries)||!entries.length||entries[0].contentRect.width<=0||entries[0].contentRect.height<=0||this._svc.setSize(entries[0].contentRect)}))})),this._observer.observe(this._elementRef.nativeElement)}ngOnDestroy(){this._observer.unobserve(this._elementRef.nativeElement),this._observer.disconnect()}getTranslate(axis,size){return this.scales.pipe((0,withLatestFrom.E)(this.config),(0,map.T)((data=>{const[{x,y},config]=data,xAxesArray=Array.from(x.values()),yAxesArray=Array.from(y.values()),oppositeFilter=this.filterPositionMap.get(!0),nonOppositeFilter=this.filterPositionMap.get(!1),oppositeOffsetY=yAxesArray.filter(oppositeFilter(axis)),nonOppositeOffsetY=yAxesArray.filter(nonOppositeFilter(axis)),oppositeOffsetX=xAxesArray.filter(oppositeFilter(axis)),nonOppositeOffsetX=xAxesArray.filter(nonOppositeFilter(axis)),oppositeTranslateY=oppositeOffsetY.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.right),nonOppisteTranslateY=nonOppositeOffsetY.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.left),oppositeTranslateX=oppositeOffsetX.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.top),nonOppisteTranslateX=nonOppositeOffsetX.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.bottom),left=yAxesArray.filter((_=>_.options.visible&&!0!==_.options.opposite)).reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.left),top=xAxesArray.filter((_=>_.options.visible&&!0===_.options.opposite)).reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.top);return axis.orientation===axis_orientation.U.x?`translate(${left}, ${axis.options.opposite?oppositeTranslateX:size.height-nonOppisteTranslateX})`:axis.orientation===axis_orientation.U.y?`translate(${axis.options.opposite?size.width-oppositeTranslateY:nonOppisteTranslateY}, ${top})`:"translate(0, 0)"})))}click(event,xScales,yScales){const x=xScales.get(0)?.scale,y=yScales.get(0)?.scale;this._svc.emitChartClick({event,target:{x:x.invert(event.offsetX),y:y.invert(event.offsetY)}})}contextMenu(event,xScales,yScales){const x=xScales.get(0)?.scale,y=yScales.get(0)?.scale;this._svc.emitChartContextMenu({event,target:{x:x.invert(event.offsetX),y:y.invert(event.offsetY)}})}mouseMove(event){this._svc.setPointerMove(event)}mouseLeave(event){this._svc.setPointerMove(event)}trackSerie(index,item){return item.name?.length?item.name:index}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:scale_service.e},{type:core.ElementRef},{type:core.NgZone}]};ChartContainerComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"teta-chart-container",template:'@if ({\n  size: size | async,\n  config: config | async,\n  scales: scales | async,\n  plotBands: plotBands | async,\n  visibleRect: visibleRect | async\n}; as data) {\n  @if (data.config?.tooltip?.enable) {\n    <teta-tooltip [size]="data.size"\n                  [config]="data.config"></teta-tooltip>\n  }\n  @if (data.size?.height > 0\n  && data.size?.width > 0\n  && data.visibleRect?.height > 0\n  && data.visibleRect?.width > 0\n  && data.scales?.x.size === data.config.xAxis.length\n  && data.scales?.y.size === data.config.yAxis.length) {\n    <svg height="100%" width="100%" class="position-absolute">\n      <g class="y-axis-container">\n        @for (item of data.scales.y | keyvalue; track item.value.index) {\n          @if (item.value.selfSize > 0\n          && item.value.options.visible\n          && data.scales.x.size > 0\n          && data.scales.y.size > 0) {\n            <g\n              teta-y-axis\n              [axis]="item.value"\n              [size]="data.visibleRect"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></g>\n            <rect\n              tetaZoomable\n              fill-opacity="0"\n              [axis]="item.value"\n              [config]="data.config"\n              [size]="data.visibleRect"\n              [attr.x]="item.value.options.opposite ? 0 : -item.value.selfSize"\n              [attr.y]="0"\n              [attr.height]="data.visibleRect.height"\n              [attr.width]="item.value.selfSize"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></rect>\n          }\n        }\n      </g>\n      <g class="x-axis-container">\n        @for (item of data.scales.x | keyvalue; track item.value.index) {\n          @if (item.value.options.visible && data.scales.x.size > 0 && data.scales.y.size > 0) {\n            <g\n              teta-x-axis\n              [axis]="item.value"\n              [size]="data.visibleRect"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></g>\n            <rect\n              tetaZoomable\n              fill-opacity="0"\n              [axis]="item.value"\n              [config]="data.config"\n              [size]="data.visibleRect"\n              [attr.x]="0"\n              [attr.y]="item.value.options.opposite ? -item.value.selfSize : 0"\n              [attr.width]="data.visibleRect.width"\n              [attr.height]="item.value.selfSize"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></rect>\n          }\n        }\n      </g>\n    </svg>\n  }\n  @if (data.size?.height > 0\n  && data.size?.width > 0\n  && data.visibleRect?.height > 0\n  && data.visibleRect?.width > 0\n  && data.scales?.x.size === data.config.xAxis.length\n  && data.scales?.y.size === data.config.yAxis.length) {\n    <svg\n      tetaZoomable\n      tetaBrushable\n      class="position-absolute"\n      [size]="data.visibleRect"\n      [config]="data.config"\n      [axis]="data.config?.zoom?.type === zoomType.x ? data.scales.x.get(0) : data.scales.y.get(0)"\n      [attr.width]="data.visibleRect.width"\n      [attr.height]="data.visibleRect.height"\n      [attr.viewBox]="\'0 0 \' + data.visibleRect.width + \' \' + data.visibleRect.height"\n      [style.transform]="\'translate(\'+ data.visibleRect.x +\'px, \'+ data.visibleRect.y +\'px)\'"\n      (contextmenu)="contextMenu($event, data.scales.x, data.scales.y)"\n      (click)="click($event, data.scales.x, data.scales.y)"\n      (mouseleave)="mouseLeave($event)"\n      (mousemove)="mouseMove($event)">\n      @if (data.config.gridLines?.enable !== false) {\n        <g class="gridlines"\n           teta-gridlines\n           [size]="data.size"></g>\n      }\n      <g class="x-axis-plotband-container">\n        @for (plotBand of data.plotBands; track plotBand) {\n          <g teta-plot-band\n             [plotBand]="plotBand.plotBand"\n             [scale]="plotBand.axis.scale"\n             [size]="data.visibleRect"\n             [axis]="plotBand.axis"></g>\n        }\n      </g>\n      <g class="series-container">\n        @for (series of data.config.series; track series; ) {\n          @if (series.visible) {\n            <g teta-series-host\n               [config]="data.config"\n               [series]="series"></g>\n          }\n        }\n      </g>\n      <g class="x-axis-plotline-container">\n        @for (axis of data.config.xAxis; let i = $index; track axis) {\n          @for (plotLine of axis.plotLines; track plotLine) {\n            <g teta-plot-line\n               [plotLine]="plotLine"\n               [scale]="data.scales.x.get(i).scale"\n               [size]="data.size"\n               [axis]="data.scales.x.get(i)"></g>\n          }\n        }\n      </g>\n      <g class="y-axis-plotline-container">\n        @for (axis of data.config.yAxis; let i = $index; track axis; ) {\n          @for (plotLine of axis.plotLines; track plotLine) {\n            <g teta-plot-line\n               [plotLine]="plotLine"\n               [scale]="data.scales.y.get(i).scale"\n               [size]="data.size"\n               [axis]="data.scales.y.get(i)"></g>\n          }\n        }\n      </g>\n      <g class="annotations">\n        @for (annotation of data.config.annotations; track annotation) {\n          <g teta-annotation\n             [visibleRect]="data.visibleRect"\n             [annotation]="annotation"></g>\n        }\n      </g>\n      @if (data.config.tooltip?.showCrosshair) {\n        <g class="crosshair">\n          <g teta-crosshair [size]="data.visibleRect"></g>\n        </g>\n      }\n    </svg>\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[TooltipComponent,ZoomableDirective,XAxisComponent,YAxisComponent,common.AsyncPipe,common.KeyValuePipe,PlotBandComponent,GridlinesComponent,SeriesHostComponent,PlotlineComponent,AnnotationComponent,CrosshairComponent,BrushableDirective],styles:[chart_container_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,scale_service.e,core.ElementRef,core.NgZone])],ChartContainerComponent);var legend_componentngResource=__webpack_require__("./projects/chart/src/chart/legend/legend.component.scss?ngResource"),legend_componentngResource_default=__webpack_require__.n(legend_componentngResource);let LegendComponent=class LegendComponent{constructor(chartService){this.chartService=chartService,this.sizeMapping=(new Map).set(series_type.O.line,2).set(series_type.O.scatter,2).set(series_type.O.bar,12).set(series_type.O.area,2).set(series_type.O.block,12).set(series_type.O.blockArea,2),this.classLegend=!0}getHeight(serie){return this.sizeMapping.get(serie.type??series_type.O.line)}click(serie){this.chartService.toggleVisibilitySeries([serie.id])}static#_=this.ctorParameters=()=>[{type:chart_service.u}];static#_2=this.propDecorators={series:[{type:core.Input}],classLegend:[{type:core.HostBinding,args:["class.padding-bottom-4"]}]}};LegendComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"teta-legend",template:'@for (serie of series; track serie.id) {\n  @if (serie?.showInLegend !== false) {\n    <div>\n      <div class="legend-item cursor-pointer"\n           (click)="click(serie)">\n        <div class="legend-icon-form"\n             [style.height.px]="getHeight(serie)"\n             [style.border-top-color]="serie.visible ? serie.color : \'var(--color-text-30)\'"\n             [style.border-top-style]="serie.style?.strokeDasharray ? \'dashed\' : \'solid\'"\n             [style.border-width.px]="serie.style?.strokeDasharray ? 1 : 2"></div>\n        <div class="legend-label" style="user-select: none"\n             [style.text-decoration]="serie.visible ? \'none\' : \'line-through\'">{{ serie.name }}\n        </div>\n      </div>\n    </div>\n  }\n}\n',standalone:!0,changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[legend_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u])],LegendComponent);let ChartComponent=class ChartComponent{set config(config){this.chartService.setConfig(config),this.zoomService.setBroadcastChannel(config?.zoom?.syncChannel)}constructor(chartService,zoomService,brushService,scaleService){this.chartService=chartService,this.zoomService=zoomService,this.brushService=brushService,this.scaleService=scaleService,this.pointerMove=new core.EventEmitter,this.plotBandsMove=new core.EventEmitter,this.plotBandClick=new core.EventEmitter,this.plotBandContextMenu=new core.EventEmitter,this.plotLinesMove=new core.EventEmitter,this.pointMove=new core.EventEmitter,this.chartClick=new core.EventEmitter,this.chartContextMenu=new core.EventEmitter,this.annotationContextMenu=new core.EventEmitter,this.annotationClick=new core.EventEmitter,this.annotationMove=new core.EventEmitter,this.zoomServiceInstance=new core.EventEmitter,this.brushServiceInstance=new core.EventEmitter,this._alive=!0,this.svcConfig=this.chartService.config,this.hasSeriesData=this.svcConfig.pipe((0,map.T)((_=>_.series?.length>0&&_.series?.some((_=>_.data?.length>0)))))}resetZoom(){this.scaleService.resetZoom()}ngOnInit(){this.zoomServiceInstance.emit(this.zoomService),this.brushServiceInstance.emit(this.brushService),this.chartService.pointerMove.pipe((0,takeWhile.v)((()=>this._alive)),(0,withLatestFrom.E)(this.scaleService.scales,this.chartService.config)).subscribe((data=>{const[event,{x,y},config]=data,tooltipTracking=config?.tooltip?.tracking;if(tooltipTracking===tooltip_tracking.V.y){const result=new Map;y.forEach(((value,key)=>{value.options.scaleType.type!==scale_type.b.band&&result.set(key,value.scale.invert(event.offsetY))})),this.pointerMove.emit({event,target:result})}else{const result=new Map;x.forEach(((value,key)=>{value.options.scaleType.type!==scale_type.b.band&&result.set(key,value.scale.invert(event.offsetX))})),this.pointerMove.emit({event,target:result})}})),this.chartService.plotBandEvent.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.plotBandsMove.emit(_)})),this.chartService.plotLineMove.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.plotLinesMove.emit(_)})),this.chartService.pointMove.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.pointMove.emit(_)})),this.chartService.chartClick.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.chartClick.emit(_)})),this.chartService.chartContextMenu.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.chartContextMenu.emit(_)})),this.chartService.plotBandClick.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.plotBandClick.emit(_)})),this.chartService.plotBandContextMenu.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.plotBandContextMenu.emit(_)})),this.chartService.annotationContextMenu.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.annotationContextMenu.emit(_)})),this.chartService.annotationClick.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.annotationClick.emit(_)})),this.chartService.annotationMove.pipe((0,takeWhile.v)((()=>this._alive))).subscribe((_=>{this.annotationMove.emit(_)}))}ngOnDestroy(){this._alive=!1}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:zoom_service.T},{type:BrushService},{type:scale_service.e}];static#_2=this.propDecorators={pointerMove:[{type:core.Output}],plotBandsMove:[{type:core.Output}],plotBandClick:[{type:core.Output}],plotBandContextMenu:[{type:core.Output}],plotLinesMove:[{type:core.Output}],pointMove:[{type:core.Output}],chartClick:[{type:core.Output}],chartContextMenu:[{type:core.Output}],annotationContextMenu:[{type:core.Output}],annotationClick:[{type:core.Output}],annotationMove:[{type:core.Output}],zoomServiceInstance:[{type:core.Output}],brushServiceInstance:[{type:core.Output}],config:[{type:core.Input}]}};ChartComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"teta-svg-chart",template:'@if ({\n  hasSeriesData: hasSeriesData | async,\n  svcConfig: svcConfig | async\n}; as data) {\n  @if (data.hasSeriesData === true) {\n    <div class="column column_auto">\n      <teta-chart-container class="chart-container position-relative"></teta-chart-container>\n    </div>\n    @if (data.svcConfig.legend?.enable === true) {\n      <teta-legend [series]="data.svcConfig.series"></teta-legend>\n    }\n  } @else {\n    <div class="column column_auto justify-content-center">\n    <span class="font-body-3 color-text-40 overflow-hidden text-overflow-ellipsis nowrap text-align-center">\n      <div #ref><ng-content></ng-content></div>\n      @if (!ref.hasChildNodes()) {\n        <span>\n          No data\n        </span>\n      }\n    </span>\n    </div>\n  }\n}\n',standalone:!0,providers:[chart_service.u,zoom_service.T,scale_service.e,BrushService],changeDetection:core.ChangeDetectionStrategy.OnPush,imports:[ChartContainerComponent,common.AsyncPipe,LegendComponent],styles:[chart_componentngResource_default()]}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,zoom_service.T,BrushService,scale_service.e])],ChartComponent)},"./projects/chart/src/chart/core/utils/get-text-width.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{q:()=>getTextWidth});const getTextWidth=(inputText,backupRatio=.5,fontSize=10)=>{let text=inputText??"";return text=text.toString(),fontSize*backupRatio*text.length}},"./projects/chart/src/chart/model/chart-bounds.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{C:()=>ChartBounds});class ChartBounds{constructor(options){this.top=0,this.right=0,this.bottom=0,this.left=0,this.top=options?.top||0,this.right=options?.right||0,this.bottom=options?.bottom||0,this.left=options?.left||0}}},"./projects/chart/src/chart/model/enum/axis-orientation.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var AxisOrientation;__webpack_require__.d(__webpack_exports__,{U:()=>AxisOrientation}),function(AxisOrientation){AxisOrientation[AxisOrientation.x=0]="x",AxisOrientation[AxisOrientation.y=1]="y"}(AxisOrientation||(AxisOrientation={}))},"./projects/chart/src/chart/model/enum/brush-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var BrushType;__webpack_require__.d(__webpack_exports__,{p:()=>BrushType}),function(BrushType){BrushType[BrushType.x=0]="x",BrushType[BrushType.y=1]="y",BrushType[BrushType.xy=2]="xy"}(BrushType||(BrushType={}))},"./projects/chart/src/chart/model/enum/clip-points-direction.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var ClipPointsDirection;__webpack_require__.d(__webpack_exports__,{$:()=>ClipPointsDirection}),function(ClipPointsDirection){ClipPointsDirection[ClipPointsDirection.x=0]="x",ClipPointsDirection[ClipPointsDirection.y=1]="y",ClipPointsDirection[ClipPointsDirection.none=2]="none"}(ClipPointsDirection||(ClipPointsDirection={}))},"./projects/chart/src/chart/model/enum/drag-point-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var DragPointType;__webpack_require__.d(__webpack_exports__,{D:()=>DragPointType}),function(DragPointType){DragPointType[DragPointType.x=0]="x",DragPointType[DragPointType.y=1]="y",DragPointType[DragPointType.xy=2]="xy"}(DragPointType||(DragPointType={}))},"./projects/chart/src/chart/model/enum/fill-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var FillType,FillDirection;__webpack_require__.d(__webpack_exports__,{F:()=>FillDirection,k:()=>FillType}),function(FillType){FillType[FillType.default=0]="default",FillType[FillType.gradient=1]="gradient"}(FillType||(FillType={})),function(FillDirection){FillDirection[FillDirection.x=0]="x",FillDirection[FillDirection.y=1]="y"}(FillDirection||(FillDirection={}))},"./projects/chart/src/chart/model/enum/scale-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var ScaleType;__webpack_require__.d(__webpack_exports__,{b:()=>ScaleType}),function(ScaleType){ScaleType[ScaleType.linear=0]="linear",ScaleType[ScaleType.log=1]="log",ScaleType[ScaleType.symlog=2]="symlog",ScaleType[ScaleType.pow=3]="pow",ScaleType[ScaleType.sqrt=4]="sqrt",ScaleType[ScaleType.time=5]="time",ScaleType[ScaleType.band=6]="band"}(ScaleType||(ScaleType={}))},"./projects/chart/src/chart/model/enum/series-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var SeriesType;__webpack_require__.d(__webpack_exports__,{O:()=>SeriesType}),function(SeriesType){SeriesType[SeriesType.line=0]="line",SeriesType[SeriesType.bar=1]="bar",SeriesType[SeriesType.area=2]="area",SeriesType[SeriesType.scatter=3]="scatter",SeriesType[SeriesType.block=4]="block",SeriesType[SeriesType.blockArea=5]="blockArea"}(SeriesType||(SeriesType={}))},"./projects/chart/src/chart/model/enum/tooltip-tracking.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var TooltipTracking;__webpack_require__.d(__webpack_exports__,{V:()=>TooltipTracking}),function(TooltipTracking){TooltipTracking[TooltipTracking.x=0]="x",TooltipTracking[TooltipTracking.y=1]="y"}(TooltipTracking||(TooltipTracking={}))},"./projects/chart/src/chart/model/enum/zoom-behavior-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var ZoomBehaviorType;__webpack_require__.d(__webpack_exports__,{u:()=>ZoomBehaviorType}),function(ZoomBehaviorType){ZoomBehaviorType[ZoomBehaviorType.move=0]="move",ZoomBehaviorType[ZoomBehaviorType.wheel=1]="wheel"}(ZoomBehaviorType||(ZoomBehaviorType={}))},"./projects/chart/src/chart/model/enum/zoom-type.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var ZoomType;__webpack_require__.d(__webpack_exports__,{C:()=>ZoomType}),function(ZoomType){ZoomType[ZoomType.x=0]="x",ZoomType[ZoomType.y=1]="y",ZoomType[ZoomType.xy=2]="xy"}(ZoomType||(ZoomType={}))},"./projects/chart/src/chart/model/i-broadcast-message.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{S:()=>BrushMessage,T:()=>ZoomMessage});class ZoomMessage{constructor(options){this.eventType=options?.eventType,this.element=options?.element,this.axis=options?.axis,this.domain=options.domain,this.chartId=options?.chartId,this.style=options?.style}}class BrushMessage{constructor(options){this.chartId=options?.chartId,this.selection=options?.selection,this.mode=options?.mode}}},"./projects/chart/src/chart/service/chart.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{u:()=>ChartService});var asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),BehaviorSubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js"),of=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/of.js"),withLatestFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js"),shareReplay=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"),filter=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/filter.js"),lastValueFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js"),take=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/take.js");const defaultAxisConfig={visible:!0,zoom:!0,scaleType:{type:__webpack_require__("./projects/chart/src/chart/model/enum/scale-type.ts").b.linear},niceTicks:!1};var zoom_type=__webpack_require__("./projects/chart/src/chart/model/enum/zoom-type.ts"),chart_bounds=__webpack_require__("./projects/chart/src/chart/model/chart-bounds.ts"),tooltip_tracking=__webpack_require__("./projects/chart/src/chart/model/enum/tooltip-tracking.ts"),zoom_behavior_type=__webpack_require__("./projects/chart/src/chart/model/enum/zoom-behavior-type.ts");const defaultChartConfig=()=>({name:null,zoom:{enable:!0,type:zoom_type.C.x,syncType:zoom_type.C.xy,zoomBehavior:zoom_behavior_type.u.move},bounds:new chart_bounds.C({bottom:12,left:12,top:12,right:12}),legend:{enable:!0},tooltip:{enable:!0,showMarkers:!0,tracking:tooltip_tracking.V.x,showCrosshair:!1,padding:{x:16,y:16}},xAxis:[],yAxis:[],series:[],gridLines:{enable:!0}});var series_type=__webpack_require__("./projects/chart/src/chart/model/enum/series-type.ts"),fill_type=__webpack_require__("./projects/chart/src/chart/model/enum/fill-type.ts"),clip_points_direction=__webpack_require__("./projects/chart/src/chart/model/enum/clip-points-direction.ts");var ChartService_1;let ChartService=class ChartService{static#_=ChartService_1=this;static#_2=this._hiddenSeriesPostfix="hidden_series";constructor(){this.config$=new BehaviorSubject.t(defaultChartConfig()),this.size$=new BehaviorSubject.t(null),this.pointerMove$=new Subject.B,this.tooltips$=new BehaviorSubject.t(new Map),this.plotBandEvent$=new Subject.B,this.plotLineMove$=new Subject.B,this.pointMove$=new Subject.B,this.chartClick$=new Subject.B,this.chartContextMenu$=new Subject.B,this.annotationEvent$=new Subject.B,this.annotationMove$=new Subject.B,this.id=(0,of.of)((Date.now()+Math.random()).toString(36)),this.config=this.config$.asObservable().pipe((0,withLatestFrom.E)(this.id),(0,map.T)(this.setDefaults),(0,map.T)(this.setPreparationData),(0,map.T)(this.restoreLocalStorage),(0,shareReplay.t)({bufferSize:1,refCount:!0})),this.size=this.size$.asObservable().pipe((0,filter.p)((size=>null!=size))),this.pointerMove=this.pointerMove$.asObservable(),this.tooltips=this.tooltips$.asObservable(),this.plotBandEvent=this.plotBandEvent$.asObservable(),this.plotLineMove=this.plotLineMove$.asObservable(),this.pointMove=this.pointMove$.asObservable(),this.chartClick=this.chartClick$.asObservable(),this.chartContextMenu=this.chartContextMenu$.asObservable(),this.annotationClick=this.annotationEvent$.asObservable().pipe((0,filter.p)((_=>"click"===_?.event?.type))),this.annotationContextMenu=this.annotationEvent$.asObservable().pipe((0,filter.p)((_=>"contextmenu"===_?.event?.type))),this.annotationMove=this.annotationMove$.asObservable(),this.plotBandClick=this.plotBandEvent$.asObservable().pipe((0,filter.p)((_=>"click"===_?.event?.type))),this.plotBandContextMenu=this.plotBandEvent$.asObservable().pipe((0,filter.p)((_=>"contextmenu"===_?.event?.type)))}setConfig(config){this.clearTooltips(),this.config$.next(config)}setSize(size){this.size$.next(size)}setPointerMove(event){this.pointerMove$.next(event)}setTooltip(tooltip){const currentTooltips=this.tooltips$.value;tooltip.point?currentTooltips.set(tooltip.series,tooltip):currentTooltips.delete(tooltip.series),this.tooltips$.next(new Map(currentTooltips))}clearTooltips(){this.tooltips$.next(new Map)}toggleVisibilitySeries(seriesIndex,visible){var _this=this;return(0,asyncToGenerator.A)((function*(){if(0===seriesIndex?.length)return;const currentConfig=yield(0,lastValueFrom.s)(_this.config.pipe((0,take.s)(1)));seriesIndex.forEach((serieIndex=>{const currentSerieIndex=currentConfig.series.findIndex((_=>_.id===serieIndex));if(-1===currentSerieIndex)return;currentConfig.series[currentSerieIndex].visible=void 0!==visible?visible:!currentConfig.series[currentSerieIndex].visible;const seriesLinkCount=currentConfig.series.filter((_=>_.yAxisIndex===currentConfig.series[currentSerieIndex].yAxisIndex&&!0===_.visible)).length;currentConfig.yAxis[currentConfig.series[currentSerieIndex].yAxisIndex].visible=0!==seriesLinkCount}));try{_this.saveCookie(currentConfig)}finally{_this.config$.next(currentConfig)}}))()}emitMoveAnnotation(event){this.annotationMove$.next(event)}emitAnnotation(event){this.annotationEvent$.next(event)}emitPlotband(event){this.plotBandEvent$.next(event)}emitPlotline(event){this.plotLineMove$.next(event)}emitPoint(event){this.pointMove$.next(event)}emitChartClick(event){this.chartClick$.next(event)}emitChartContextMenu(event){this.chartContextMenu$.next(event)}saveCookie(config){if(!config.name)return;const hiddenSeries=config.series?.filter((_=>!_.visible)).map((_=>_.id));localStorage.setItem(`${config.name}_${ChartService_1._hiddenSeriesPostfix}`,JSON.stringify(hiddenSeries))}restoreLocalStorage(config){if(!config.name)return config;const hiddenSeries=localStorage.getItem(`${config.name}_${ChartService_1._hiddenSeriesPostfix}`);if(hiddenSeries){const json=JSON.parse(hiddenSeries);return config.series=config.series.map(((serie,index)=>{serie.visible=!json.includes(serie.id);const currentSerieIndex=config.series.findIndex((_=>_.id===serie.id));if(-1!==currentSerieIndex){const seriesLinkCount=config.series.filter((_=>_.yAxisIndex===config.series[currentSerieIndex].yAxisIndex&&!0===_.visible)).length;config.yAxis[config.series[currentSerieIndex].yAxisIndex].visible=0!==seriesLinkCount}return serie})),config}return config}setDefaults(data){let[config,id]=data;const defaultConfig=defaultConfig=>source=>Object.assign({},defaultConfig,source);config=Object.assign({},defaultChartConfig(),config),config.id=config.id??id,config.xAxis=config.xAxis.map(defaultConfig(defaultAxisConfig)),config.yAxis=config.yAxis.map(defaultConfig(defaultAxisConfig)),config.series=config.series.map(defaultConfig({data:[],type:series_type.O.line,xAxisIndex:0,yAxisIndex:0,fillType:fill_type.k.default,color:"coral",visible:!0,clipPointsDirection:clip_points_direction.$.x})),config.series=config.series.map(((_,index)=>({..._,data:_.data??[],id:_.id??index})));const oppositeYCount=config.yAxis?.filter((_=>_.opposite)),oppositeXCount=config.xAxis?.filter((_=>_.opposite)),nonOppositeYCount=config.yAxis?.filter((_=>!_.opposite)),nonOppositeXCount=config.xAxis?.filter((_=>!_.opposite));return nonOppositeXCount?.length>1&&(config.bounds.bottom=0),oppositeXCount?.length>1&&(config.bounds.top=0),nonOppositeYCount?.length>1&&(config.bounds.left=0),oppositeYCount?.length>1&&(config.bounds.right=0),config.tooltip=Object.assign({},defaultChartConfig().tooltip,config.tooltip),config.zoom=Object.assign({},defaultChartConfig().zoom,config.zoom),config.zoom.syncChannel=config.zoom?.syncChannel??id,config}setPreparationData(config){if(config.inverted){const xAxes=[...config.xAxis],yAxes=[...config.yAxis];config.xAxis=yAxes,config.yAxis=xAxes,config.series=config.series?.map((serie=>{const x=serie.xAxisIndex,y=serie.yAxisIndex;return serie.xAxisIndex=y,serie.yAxisIndex=x,{...serie,clipPointsDirection:clip_points_direction.$.y,data:serie?.data?.map((point=>({...point,x:point?.y,y:point?.x,x1:point?.y1,y1:point?.x1})))}}))}return config?.brush?.enable&&(config.yAxis=config.yAxis.map((_=>({..._,zoom:!1}))),config.xAxis=config.xAxis.map((_=>({..._,zoom:!1})))),config}static#_3=this.ctorParameters=()=>[]};ChartService=ChartService_1=(0,tslib_es6.Cg)([(0,core.Injectable)({providedIn:"root"}),(0,tslib_es6.Sn)("design:paramtypes",[])],ChartService)},"./projects/chart/src/chart/service/scale.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{e:()=>ScaleService});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),src=__webpack_require__("./node_modules/d3/src/index.js"),combineLatest=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js"),shareReplay=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"),take=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/take.js"),withLatestFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js"),axis_orientation=__webpack_require__("./projects/chart/src/chart/model/enum/axis-orientation.ts"),scale_type=__webpack_require__("./projects/chart/src/chart/model/enum/scale-type.ts");class ExtremesBuilder{constructor(){this.extentAccessorMap=(new Map).set(axis_orientation.U.x,(_=>_.x)).set(axis_orientation.U.y,(_=>_.y)),this.extremes=[0,1]}build(settings){const options=settings.options;let extremes=[];const hasMin=null!=options?.min,hasMax=null!=options?.max;if(!hasMin||!hasMax){const data=settings.linkedSeries().reduce(((acc,current)=>acc.concat(current.data)),[]),accessor=this.extentAccessorMap.get(settings.orientation);extremes=settings.options.scaleType.type===scale_type.b.band?data.map(accessor):data.length>0?src.Xxv(data,accessor):[0,1]}return hasMin&&(extremes[0]=options?.min),hasMax&&(extremes[1]=options?.max),"number"==typeof extremes[0]&&"number"==typeof extremes[1]&&extremes[0]===extremes[1]&&(extremes[0]=extremes[0]-1,extremes[1]=extremes[1]+1),this.extremes=extremes,this.extremes}}var get_text_width=__webpack_require__("./projects/chart/src/chart/core/utils/get-text-width.ts");class AxisSizeBuilder{constructor(){this.titlePadding=11,this.basePadding=16,this.backupRatio=.58}build(settings){let finalPadding=this.basePadding;if(settings.orientation===axis_orientation.U.y){const formatter=settings.options.tickFormat||settings.defaultFormatter();finalPadding+=settings.options.title?this.titlePadding:0;const scale=settings.defaultScale()();scale.domain(settings.extremes),settings.options.scaleType.type===scale_type.b.band&&(scale.ticks=ticks=>scale.domain());const ticks=scale.ticks(20),maxElementLengthIndex=function maxIndex(values,valueof){let max,maxIndex=-1,index=-1;if(void 0===valueof)for(const value of values)++index,null!=value&&(max<value||void 0===max&&value>=value)&&(max=value,maxIndex=index);else for(let value of values)null!=(value=valueof(value,++index,values))&&(max<value||void 0===max&&value>=value)&&(max=value,maxIndex=index);return maxIndex}(ticks,(_=>formatter(_).length));finalPadding+=(0,get_text_width.q)(formatter(ticks[maxElementLengthIndex]),this.backupRatio)}return settings.orientation===axis_orientation.U.x&&(finalPadding+=finalPadding+20),finalPadding}}class Axis{constructor(config){this._extremes=[0,0],this._originDomain=[0,0],this.defaultFormatters=(new Map).set(scale_type.b.linear,src.GPZ(",.5~r")).set(scale_type.b.time,src.DCK("%d.%m.%Y")).set(scale_type.b.log,src.GPZ("~s")).set(scale_type.b.symlog,src.GPZ("~s")).set(scale_type.b.pow,src.GPZ("~s")).set(scale_type.b.sqrt,src.GPZ("~s")).set(scale_type.b.band,(_=>_)),this.defaultScales=(new Map).set(scale_type.b.linear,src.m4Y).set(scale_type.b.log,src.ZEH).set(scale_type.b.symlog,src.aX1).set(scale_type.b.pow,src.RWy).set(scale_type.b.sqrt,src.Bv9).set(scale_type.b.time,src.w7C).set(scale_type.b.band,src.WH),this.chartConfig=config}static createAxis(orientation,config,index){const axis=new Axis(config);return axis.setLocate(orientation),axis.setIndex(index),axis.setOptions(),axis.setExtremes(),axis.setTicksValues(),axis.setSelfSize(),axis}setLocate(orientation){this._orientation=orientation}setIndex(index){this._index=index}linkedSeries(){return this.chartConfig?.series.filter((serie=>serie[this._orientation===axis_orientation.U.y?"yAxisIndex":"xAxisIndex"]===this._index))}setExtremes(){const builder=new ExtremesBuilder;this._extremes=builder.build(this)}setOriginDomain(domain){this._originDomain=domain}setScale(scale){this._scale=scale,this.options.scaleType.type===scale_type.b.band&&(this._scale.ticks=()=>this._scale.domain())}setSelfSize(){this._selfSize=(new AxisSizeBuilder).build(this)}setTicksValues(){}setOptions(){const options=this.orientation===axis_orientation.U.x?this.chartConfig.xAxis[this.index]:this.chartConfig.yAxis[this.index];this._options=options}get scale(){return this._scale}get extremes(){return this._extremes}get orientation(){return this._orientation}get selfSize(){return this._selfSize}get tickValues(){return this._ticksValues}get index(){return this._index}get options(){return this._options}get originDomain(){return this._originDomain}defaultFormatter(){return this.defaultFormatters.get(this.options.scaleType.type)}defaultScale(){return this.defaultScales.get(this.options.scaleType.type)}}var zoom_type=__webpack_require__("./projects/chart/src/chart/model/enum/zoom-type.ts"),i_broadcast_message=__webpack_require__("./projects/chart/src/chart/model/i-broadcast-message.ts"),chart_service=__webpack_require__("./projects/chart/src/chart/service/chart.service.ts"),zoom_service=__webpack_require__("./projects/chart/src/chart/service/zoom.service.ts");let ScaleService=class ScaleService{constructor(chartService,zoomService){this.chartService=chartService,this.zoomService=zoomService,this.transformCacheX=new Map,this.transformCacheY=new Map,this.scaleMapping=(new Map).set(scale_type.b.linear,src.m4Y).set(scale_type.b.time,src.w7C).set(scale_type.b.log,src.ZEH).set(scale_type.b.symlog,src.aX1).set(scale_type.b.pow,src.RWy).set(scale_type.b.sqrt,src.Bv9).set(scale_type.b.band,src.WH),this.scales=(0,combineLatest.z)([this.chartService.size,this.chartService.config,this.zoomService.zoomed]).pipe((0,map.T)((data=>{const[size,config,zoom]=data,xAxisMap=new Map,yAxisMap=new Map;config.yAxis.map(((_,index)=>{yAxisMap.set(index,Axis.createAxis(axis_orientation.U.y,config,index))})),config.xAxis.map(((_,index)=>{xAxisMap.set(index,Axis.createAxis(axis_orientation.U.x,config,index))}));const left=Array.from(yAxisMap.values()).filter((_=>_.options?.visible&&_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),right=Array.from(yAxisMap.values()).filter((_=>_.options?.visible&&!0!==_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),finalWidth=(size.width||0)-left-right;if(xAxisMap.forEach((axis=>{let domain=axis.extremes;axis?.options.inverted&&(domain=[...axis.extremes].reverse());const scale=this.scaleMapping.get(axis.options.scaleType.type)().domain(domain).range([0,finalWidth-config.bounds.right]);axis.options.niceTicks&&scale.nice(),axis.options.scaleType.type===scale_type.b.log&&scale.base(axis.options.scaleType.base),axis.options.scaleType.type===scale_type.b.band&&(scale.paddingInner(.1),scale.paddingOuter(.1),scale.align(.1)),axis.setScale(scale),axis.setOriginDomain(scale.domain());const hasCache=this.transformCacheX.has(axis.index),shouldRestore=zoom?.axis?.orientation!==axis_orientation.U.x||zoom.axis?.index!==axis.index;if(hasCache&&shouldRestore){const restoredTransform=this.transformCacheX.get(axis.index);axis.setScale(restoredTransform.rescaleX(scale))}})),zoom&&zoom.domain&&zoom.axis?.orientation===axis_orientation.U.x&&xAxisMap.has(zoom.axis.index)){const x=xAxisMap.get(zoom.axis.index),transform=this.zoomService.getD3Transform(zoom.domain,x.originDomain,x.scale,axis_orientation.U.x,x.options.inverted),rescaled=transform.rescaleX(x.scale.copy());x.setScale(rescaled),this.transformCacheX.set(x.index,transform)}const top=Array.from(xAxisMap.values()).filter((_=>_.options?.visible&&_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),bottom=Array.from(xAxisMap.values()).filter((_=>_.options?.visible&&!0!==_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),finalHeight=(size.height||0)-top-bottom-config?.bounds?.top-config.bounds?.bottom;if(yAxisMap.forEach((axis=>{let domain=axis.extremes;axis.orientation===axis_orientation.U.y&&(domain=[...axis.extremes].reverse()),axis?.options.inverted&&(domain=domain.reverse());const scale=this.scaleMapping.get(axis.options.scaleType.type)().domain(domain).range([config.bounds.top,finalHeight]);axis.options.niceTicks&&scale.nice(),axis.options.scaleType.type===scale_type.b.log&&scale.base(axis.options.scaleType.base),axis.options.scaleType.type===scale_type.b.band&&(scale.paddingInner(.1),scale.paddingOuter(.1),scale.align(.1)),axis.setScale(scale),axis.setOriginDomain(scale.domain());const hasCache=this.transformCacheY.has(axis.index),shouldRestore=zoom?.axis?.orientation!==axis_orientation.U.y||zoom.axis?.index!==axis.index;if(hasCache&&shouldRestore){const restoredTransform=this.transformCacheY.get(axis.index);axis.setScale(restoredTransform.rescaleY(scale))}})),zoom&&zoom.domain&&zoom.axis?.orientation===axis_orientation.U.y&&yAxisMap.has(zoom.axis.index)){const y=yAxisMap.get(zoom.axis.index),transform=this.zoomService.getD3Transform(zoom.domain,y.originDomain,y.scale,axis_orientation.U.y,y.options.inverted),rescaled=transform.rescaleY(y.scale.copy());y.setScale(rescaled),this.transformCacheY.set(y.index,transform)}return{x:xAxisMap,y:yAxisMap}})),(0,shareReplay.t)({bufferSize:1,refCount:!0}))}resetZoom(){this.chartService.config.pipe((0,take.s)(1),(0,withLatestFrom.E)(this.scales)).subscribe((([config,scales])=>{config.xAxis.forEach(((axis,index)=>{const scale=scales?.x?.get(index)?.originDomain;if(scale){const msg=new i_broadcast_message.T({eventType:"end",axis:{index,orientation:axis_orientation.U.x},domain:scale,chartId:config.id});this.zoomService.fireZoom(msg),config.zoom.syncChannel&&config.zoom.syncType===zoom_type.C.x&&this.zoomService.broadcastZoom(msg)}})),config.yAxis.forEach(((axis,index)=>{const scale=scales?.y?.get(index)?.originDomain;if(scale){const msg=new i_broadcast_message.T({eventType:"end",axis:{index,orientation:axis_orientation.U.y},domain:scale,chartId:config.id});this.zoomService.fireZoom(msg),config.zoom.syncChannel&&config.zoom.syncType===zoom_type.C.y&&this.zoomService.broadcastZoom(msg)}}))}))}static#_=this.ctorParameters=()=>[{type:chart_service.u},{type:zoom_service.T}]};ScaleService=(0,tslib_es6.Cg)([(0,core.Injectable)({providedIn:"root"}),(0,tslib_es6.Sn)("design:paramtypes",[chart_service.u,zoom_service.T])],ScaleService)},"./projects/chart/src/chart/service/zoom.service.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{T:()=>ZoomService});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),BehaviorSubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),shareReplay=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"),combineLatest=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js"),filter=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/filter.js"),axis_orientation=__webpack_require__("./projects/chart/src/chart/model/enum/axis-orientation.ts"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),src=__webpack_require__("./node_modules/d3/src/index.js"),ReplaySubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");let BroadcastService=class BroadcastService{constructor(){this.zoomEmitter=new ReplaySubject.m(1)}broadcastZoom(value){this.zoomEmitter.next(value)}subscribeToZoom(channel){return this.zoomEmitter.asObservable().pipe((0,filter.p)((msg=>channel&&msg.channel===channel)))}static#_=this.ctorParameters=()=>[]};BroadcastService=(0,tslib_es6.Cg)([(0,core.Injectable)({providedIn:"root"}),(0,tslib_es6.Sn)("design:paramtypes",[])],BroadcastService);var chart_service=__webpack_require__("./projects/chart/src/chart/service/chart.service.ts"),zoom_type=__webpack_require__("./projects/chart/src/chart/model/enum/zoom-type.ts");let ZoomService=class ZoomService{constructor(_broadcast,_chart){this._broadcast=_broadcast,this._chart=_chart,this.zoomed$=new BehaviorSubject.t(null),this.zoomed=this.zoomed$.asObservable().pipe((0,shareReplay.t)({bufferSize:1,refCount:!0}))}fireZoom(zoom){this.zoomed$.next(zoom)}broadcastZoom(zoom){this.broadcastChannel?.length&&this._broadcast.broadcastZoom({channel:this.broadcastChannel,message:zoom})}setBroadcastChannel(channel){this.broadcastSub&&this.broadcastSub?.unsubscribe(),this.broadcastChannel=channel,this.broadcastChannel?.length&&(this.broadcastSub=(0,combineLatest.z)([this._broadcast.subscribeToZoom(this.broadcastChannel),this._chart.config]).pipe((0,filter.p)((([zoom,config])=>zoom.message?.chartId!==config.id&&(config.zoom.syncType===zoom_type.C.xy||zoom.message.axis.orientation===axis_orientation.U.y&&config.zoom.syncType===zoom_type.C.y||zoom.message.axis.orientation===axis_orientation.U.x&&config.zoom.syncType===zoom_type.C.x)))).subscribe((([zoom,config])=>{this.fireZoom(zoom.message)})))}getD3Transform(targetDomain,originalDomain,scale,orientation,inverted){const zoomScale=Math.abs(scale(originalDomain[1])-scale(originalDomain[0]))/Math.abs(scale(targetDomain[1])-scale(targetDomain[0]));let transform=src.GSI.scale(zoomScale);return orientation===axis_orientation.U.x&&(transform=inverted?transform.translate(-scale(Math.max(...targetDomain)),0):transform.translate(-scale(Math.min(...targetDomain)),0)),orientation===axis_orientation.U.y&&(transform=inverted?transform.translate(0,-scale(Math.min(...targetDomain))):transform.translate(0,-scale(Math.max(...targetDomain)))),transform}ngOnDestroy(){this.broadcastSub?.unsubscribe()}static#_=this.ctorParameters=()=>[{type:BroadcastService},{type:chart_service.u}]};ZoomService=(0,tslib_es6.Cg)([(0,core.Injectable)({providedIn:"root"}),(0,tslib_es6.Sn)("design:paramtypes",[BroadcastService,chart_service.u])],ZoomService)},"./projects/components/src/common/enum/teta-size.enum.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var TetaSize;__webpack_require__.d(__webpack_exports__,{K:()=>TetaSize}),function(TetaSize){TetaSize[TetaSize.XS=0]="XS",TetaSize[TetaSize.S=1]="S",TetaSize[TetaSize.M=2]="M",TetaSize[TetaSize.L=3]="L",TetaSize[TetaSize.XL=4]="XL"}(TetaSize||(TetaSize={}))},"./projects/components/src/component/button/button/button.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Q:()=>ButtonComponent});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");var button_componentngResource=__webpack_require__("./projects/components/src/component/button/button/button.component.scss?ngResource"),button_componentngResource_default=__webpack_require__.n(button_componentngResource),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),teta_size_enum=__webpack_require__("./projects/components/src/common/enum/teta-size.enum.ts");let ButtonComponent=class ButtonComponent{constructor(){this.view="primary",this.square=!1,this.viewType="rounded",this.size=teta_size_enum.K.M}get getClass(){const result=[this.class,"button"];switch(this.palette&&result.push(`button-${this.palette}`),this.view&&result.push(`button_${this.view}`),this.square&&result.push("button-square"),this.size){case teta_size_enum.K.XL:result.push("button-xl");break;case teta_size_enum.K.L:result.push("button-l");break;case teta_size_enum.K.M:result.push("font-button-2"),result.push("button-m");break;case teta_size_enum.K.S:result.push("font-button-3"),result.push("button-s");break;case teta_size_enum.K.XS:result.push("font-button-3"),result.push("button-xs")}return result.push(`button_${this.viewType}`),result.join(" ")}static#_=this.propDecorators={palette:[{type:core.Input}],class:[{type:core.Input}],view:[{type:core.Input}],square:[{type:core.Input}],viewType:[{type:core.Input}],size:[{type:core.Input}],getClass:[{type:core.HostBinding,args:["class"]}]}};ButtonComponent=(0,tslib_es6.Cg)([(0,core.Component)({selector:"button[teta-button], teta-button",template:"<ng-content></ng-content>\n",changeDetection:core.ChangeDetectionStrategy.OnPush,standalone:!0,styles:[button_componentngResource_default()]})],ButtonComponent)},"./projects/components/src/component/icon/icon-sprite.directive.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{_:()=>IconSpriteDirective});var IconService_1,tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),fesm2022_http=__webpack_require__("./node_modules/@angular/common/fesm2022/http.mjs"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js");let IconService=class IconService{static#_=IconService_1=this;static#_2=this._loaded=[];static#_3=this._pending=[];constructor(_document,_rendererFactory,_httpBackend,_http){this._document=_document,this._rendererFactory=_rendererFactory,this._httpBackend=_httpBackend,this._http=_http,this._renderer=this._rendererFactory.createRenderer(null,null)}addSprite(url,bypassInterceptors=!0){IconService_1._loaded.indexOf(url)<0&&IconService_1._pending.indexOf(url)<0&&(IconService_1._pending.push(url),this.getSVG(url,bypassInterceptors).subscribe((svg=>{IconService_1._pending=IconService_1._pending.filter((_=>_!==url)),IconService_1._loaded.push(url),this._renderer.insertBefore(this._document.body,svg,this._document.body.firstChild)})))}getSVG(url,bypassInterceptors=!0){return(bypassInterceptors?new fesm2022_http.Qq(this._httpBackend):this._http).get(url,{responseType:"text"}).pipe((0,map.T)((svgText=>{const svgEl=this.svgElementFromString(svgText);return this.cloneSVG(svgEl)})))}svgElementFromString(str){const div=this._renderer.createElement("DIV");div.innerHTML=str;const svg=div.querySelector("svg");if(!svg)throw new Error("No SVG found in loaded contents");return svg}cloneSVG(svg){return svg.cloneNode(!0)}static#_4=this.ctorParameters=()=>[{type:void 0,decorators:[{type:core.Inject,args:[common.DOCUMENT]}]},{type:core.RendererFactory2},{type:fesm2022_http.JV},{type:fesm2022_http.Qq}]};IconService=IconService_1=(0,tslib_es6.Cg)([(0,core.Injectable)({providedIn:"root"}),(0,tslib_es6.Sn)("design:paramtypes",[Object,core.RendererFactory2,fesm2022_http.JV,fesm2022_http.Qq])],IconService);let IconSpriteDirective=class IconSpriteDirective{constructor(_iconService){this._iconService=_iconService,this.bypassInterceptors=!0}ngOnInit(){"string"==typeof this.tetaIconSprite&&this._iconService.addSprite(this.tetaIconSprite,this.bypassInterceptors),this.tetaIconSprite instanceof Array&&this.tetaIconSprite?.length&&this.tetaIconSprite.forEach((sprite=>{this._iconService.addSprite(sprite,this.bypassInterceptors)}))}static#_=this.ctorParameters=()=>[{type:IconService}];static#_2=this.propDecorators={tetaIconSprite:[{type:core.Input}],bypassInterceptors:[{type:core.Input}]}};IconSpriteDirective=(0,tslib_es6.Cg)([(0,core.Directive)({selector:"[tetaIconSprite]",standalone:!0}),(0,tslib_es6.Sn)("design:paramtypes",[IconService])],IconSpriteDirective)},"./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{s:()=>lastValueFrom});var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js");function lastValueFrom(source,config){var hasConfig="object"==typeof config;return new Promise((function(resolve,reject){var _value,_hasValue=!1;source.subscribe({next:function(value){_value=value,_hasValue=!0},error:reject,complete:function(){_hasValue?resolve(_value):hasConfig?resolve(config.defaultValue):reject(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__.G)}})}))}},"./node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{X:()=>animationFrameScheduler});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),AsyncAction=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js"),Subscription=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js"),animationFrameProvider={schedule:function(callback){var request=requestAnimationFrame,cancel=cancelAnimationFrame,delegate=animationFrameProvider.delegate;delegate&&(request=delegate.requestAnimationFrame,cancel=delegate.cancelAnimationFrame);var handle=request((function(timestamp){cancel=void 0,callback(timestamp)}));return new Subscription.yU((function(){return null==cancel?void 0:cancel(handle)}))},requestAnimationFrame:function(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];var delegate=animationFrameProvider.delegate;return((null==delegate?void 0:delegate.requestAnimationFrame)||requestAnimationFrame).apply(void 0,(0,tslib_es6.fX)([],(0,tslib_es6.zs)(args)))},cancelAnimationFrame:function(){for(var args=[],_i=0;_i<arguments.length;_i++)args[_i]=arguments[_i];var delegate=animationFrameProvider.delegate;return((null==delegate?void 0:delegate.cancelAnimationFrame)||cancelAnimationFrame).apply(void 0,(0,tslib_es6.fX)([],(0,tslib_es6.zs)(args)))},delegate:void 0},AnimationFrameAction=function(_super){function AnimationFrameAction(scheduler,work){var _this=_super.call(this,scheduler,work)||this;return _this.scheduler=scheduler,_this.work=work,_this}return(0,tslib_es6.C6)(AnimationFrameAction,_super),AnimationFrameAction.prototype.requestAsyncId=function(scheduler,id,delay){return void 0===delay&&(delay=0),null!==delay&&delay>0?_super.prototype.requestAsyncId.call(this,scheduler,id,delay):(scheduler.actions.push(this),scheduler._scheduled||(scheduler._scheduled=animationFrameProvider.requestAnimationFrame((function(){return scheduler.flush(void 0)}))))},AnimationFrameAction.prototype.recycleAsyncId=function(scheduler,id,delay){var _a;if(void 0===delay&&(delay=0),null!=delay?delay>0:this.delay>0)return _super.prototype.recycleAsyncId.call(this,scheduler,id,delay);var actions=scheduler.actions;null!=id&&(null===(_a=actions[actions.length-1])||void 0===_a?void 0:_a.id)!==id&&(animationFrameProvider.cancelAnimationFrame(id),scheduler._scheduled=void 0)},AnimationFrameAction}(AsyncAction.R),animationFrameScheduler=new(function(_super){function AnimationFrameScheduler(){return null!==_super&&_super.apply(this,arguments)||this}return(0,tslib_es6.C6)(AnimationFrameScheduler,_super),AnimationFrameScheduler.prototype.flush=function(action){this._active=!0;var flushId=this._scheduled;this._scheduled=void 0;var error,actions=this.actions;action=action||actions.shift();do{if(error=action.execute(action.state,action.delay))break}while((action=actions[0])&&action.id===flushId&&actions.shift());if(this._active=!1,error){for(;(action=actions[0])&&action.id===flushId&&actions.shift();)action.unsubscribe();throw error}},AnimationFrameScheduler}(__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js").q))(AnimationFrameAction)},"./projects/chart/src/chart/chart-container/annotation/annotation.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/chart-container.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  min-width: 0;\n  min-height: 0;\n}\n\n:host .zoomable:hover {\n  cursor: grab;\n}\n\n:host .zoomable:active {\n  cursor: grabbing;\n}\n\n:host .crosshair {\n  cursor: crosshair;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/crosshair/crosshair.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  shape-rendering: crispEdges;\n  pointer-events: none;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/gridlines/gridlines.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  shape-rendering: crispEdges;\n}\n\n:host line {\n  stroke: var(--color-text-5);\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/plotband/plot-band.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host .draggable rect:hover {\n  cursor: grab;\n}\n\n:host .draggable rect:active {\n  cursor: grabbing;\n}\n\n:host .x-grabber.resizeable {\n  cursor: col-resize;\n}\n\n:host .y-grabber.resizeable {\n  cursor: row-resize;\n}\n\n:host:hover .grabber {\n  opacity: 0.1;\n}\n\n.grabber {\n  opacity: 0;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/plotline/plotline.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host .x-grabber {\n  cursor: col-resize;\n}\n\n:host .y-grabber {\n  cursor: row-resize;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/area-series/area-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/bar/bar-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/block-area-series/block-area-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/block-series/block-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/line/line-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,".draggable-marker {\n  cursor: move;\n}\n\n.active {\n  stroke-opacity: 0.5;\n}\n\n.marker-grab {\n  opacity: 0;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/scatter-series/scatter-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,".draggable-marker {\n  cursor: move;\n}\n\n.active {\n  stroke-opacity: 0.5;\n}\n\n.marker-grab {\n  opacity: 0;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/tooltip/tooltip.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  position: absolute;\n  z-index: 2;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/x-axis/x-axis.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host .tick {\n  stroke: var(--color-text-20);\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/y-axis/y-axis.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  shape-rendering: crispEdges;\n}\n\n:host .label-axis {\n  fill: var(--color-text-70);\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart/chart.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  width: 100%;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/legend/legend.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  display: flex;\n  grid-gap: 8px;\n  flex-wrap: wrap;\n  align-items: center;\n  justify-content: space-evenly;\n}\n\n:host .legend-item {\n  display: flex;\n  align-items: center;\n}\n\n:host .legend-icon-form {\n  width: 12px;\n}\n\n:host .legend-label {\n  margin-left: 5px;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/components/src/component/button/button/button.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()}}]);
(self.webpackChunkteta_components=self.webpackChunkteta_components||[]).push([[1575],{"./projects/chart/src/chart/stories/Chart.stories.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{bandChart:()=>bandChart,basicChart:()=>basicChart,default:()=>Chart_stories,draggableChart:()=>draggableChart});var dist=__webpack_require__("./node_modules/@storybook/addon-knobs/dist/index.js"),tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");var ScaleType,TooltipTracking,chart_componentngResource=__webpack_require__("./projects/chart/src/chart/chart/chart.component.scss?ngResource"),chart_componentngResource_default=__webpack_require__.n(chart_componentngResource),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js"),takeWhile=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js"),withLatestFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js");!function(ScaleType){ScaleType[ScaleType.linear=0]="linear",ScaleType[ScaleType.log=1]="log",ScaleType[ScaleType.symlog=2]="symlog",ScaleType[ScaleType.pow=3]="pow",ScaleType[ScaleType.sqrt=4]="sqrt",ScaleType[ScaleType.time=5]="time",ScaleType[ScaleType.band=6]="band"}(ScaleType||(ScaleType={})),function(TooltipTracking){TooltipTracking[TooltipTracking.x=0]="x",TooltipTracking[TooltipTracking.y=1]="y"}(TooltipTracking||(TooltipTracking={}));var _class,ReplaySubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js");let BrushService=((_class=class BrushService{constructor(){this._brushDomain=new ReplaySubject.t(1),this.brushDomain=this._brushDomain.asObservable()}setBrush(brush){this._brushDomain.next(brush)}}).ctorParameters=()=>[],_class);BrushService=(0,tslib_es6.gn)([(0,core.Injectable)({providedIn:"root"})],BrushService);var asyncToGenerator=__webpack_require__("./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),BehaviorSubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js"),of=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/of.js"),shareReplay=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"),filter=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/filter.js"),lastValueFrom=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js"),take=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/take.js");const defaultAxisConfig={visible:!0,zoom:!0,scaleType:{type:ScaleType.linear},niceTicks:!1};var ZoomType,ZoomBehaviorType;!function(ZoomType){ZoomType[ZoomType.x=0]="x",ZoomType[ZoomType.y=1]="y",ZoomType[ZoomType.xy=2]="xy"}(ZoomType||(ZoomType={}));class ChartBounds{constructor(options){this.top=0,this.right=0,this.bottom=0,this.left=0,this.top=options?.top||0,this.right=options?.right||0,this.bottom=options?.bottom||0,this.left=options?.left||0}}!function(ZoomBehaviorType){ZoomBehaviorType[ZoomBehaviorType.move=0]="move",ZoomBehaviorType[ZoomBehaviorType.wheel=1]="wheel"}(ZoomBehaviorType||(ZoomBehaviorType={}));const defaultChartConfig=()=>({name:null,zoom:{enable:!0,type:ZoomType.x,syncType:ZoomType.xy,zoomBehavior:ZoomBehaviorType.move},bounds:new ChartBounds({bottom:12,left:12,top:12,right:12}),legend:{enable:!0},tooltip:{enable:!0,showMarkers:!0,tracking:TooltipTracking.x,showCrosshair:!1,padding:{x:16,y:16}},xAxis:[],yAxis:[],series:[],gridLines:{enable:!0}});var SeriesType,FillType,FillDirection,ClipPointsDirection;!function(SeriesType){SeriesType[SeriesType.line=0]="line",SeriesType[SeriesType.bar=1]="bar",SeriesType[SeriesType.area=2]="area",SeriesType[SeriesType.scatter=3]="scatter",SeriesType[SeriesType.block=4]="block",SeriesType[SeriesType.blockArea=5]="blockArea"}(SeriesType||(SeriesType={})),function(FillType){FillType[FillType.default=0]="default",FillType[FillType.gradient=1]="gradient"}(FillType||(FillType={})),function(FillDirection){FillDirection[FillDirection.x=0]="x",FillDirection[FillDirection.y=1]="y"}(FillDirection||(FillDirection={})),function(ClipPointsDirection){ClipPointsDirection[ClipPointsDirection.x=0]="x",ClipPointsDirection[ClipPointsDirection.y=1]="y",ClipPointsDirection[ClipPointsDirection.none=2]="none"}(ClipPointsDirection||(ClipPointsDirection={}));var chart_service_class,ChartService_1;let ChartService=((chart_service_class=class ChartService{constructor(){this.config$=new BehaviorSubject.X(defaultChartConfig()),this.size$=new BehaviorSubject.X(null),this.pointerMove$=new Subject.x,this.tooltips$=new BehaviorSubject.X(new Map),this.plotBandEvent$=new Subject.x,this.plotLineMove$=new Subject.x,this.pointMove$=new Subject.x,this.chartClick$=new Subject.x,this.chartContextMenu$=new Subject.x,this.annotationEvent$=new Subject.x,this.annotationMove$=new Subject.x,this.id=(0,of.of)((Date.now()+Math.random()).toString(36)),this.config=this.config$.asObservable().pipe((0,withLatestFrom.M)(this.id),(0,map.U)(this.setDefaults),(0,map.U)(this.setPreparationData),(0,map.U)(this.restoreLocalStorage),(0,shareReplay.d)({bufferSize:1,refCount:!0})),this.size=this.size$.asObservable().pipe((0,filter.h)((size=>null!=size))),this.pointerMove=this.pointerMove$.asObservable(),this.tooltips=this.tooltips$.asObservable(),this.plotBandEvent=this.plotBandEvent$.asObservable(),this.plotLineMove=this.plotLineMove$.asObservable(),this.pointMove=this.pointMove$.asObservable(),this.chartClick=this.chartClick$.asObservable(),this.chartContextMenu=this.chartContextMenu$.asObservable(),this.annotationClick=this.annotationEvent$.asObservable().pipe((0,filter.h)((_=>"click"===_?.event?.type))),this.annotationContextMenu=this.annotationEvent$.asObservable().pipe((0,filter.h)((_=>"contextmenu"===_?.event?.type))),this.annotationMove=this.annotationMove$.asObservable(),this.plotBandClick=this.plotBandEvent$.asObservable().pipe((0,filter.h)((_=>"click"===_?.event?.type))),this.plotBandContextMenu=this.plotBandEvent$.asObservable().pipe((0,filter.h)((_=>"contextmenu"===_?.event?.type)))}setConfig(config){this.clearTooltips(),this.config$.next(config)}setSize(size){this.size$.next(size)}setPointerMove(event){this.pointerMove$.next(event)}setTooltip(tooltip){const currentTooltips=this.tooltips$.value;tooltip.point?currentTooltips.set(tooltip.series,tooltip):currentTooltips.delete(tooltip.series),this.tooltips$.next(new Map(currentTooltips))}clearTooltips(){this.tooltips$.next(new Map)}toggleVisibilitySeries(seriesIndex,visible){var _this=this;return(0,asyncToGenerator.Z)((function*(){if(0===seriesIndex?.length)return;const currentConfig=yield(0,lastValueFrom.n)(_this.config.pipe((0,take.q)(1)));seriesIndex.forEach((serieIndex=>{const currentSerieIndex=currentConfig.series.findIndex((_=>_.id===serieIndex));if(-1===currentSerieIndex)return;currentConfig.series[currentSerieIndex].visible=void 0!==visible?visible:!currentConfig.series[currentSerieIndex].visible;const seriesLinkCount=currentConfig.series.filter((_=>_.yAxisIndex===currentConfig.series[currentSerieIndex].yAxisIndex&&!0===_.visible)).length;currentConfig.yAxis[currentConfig.series[currentSerieIndex].yAxisIndex].visible=0!==seriesLinkCount}));try{_this.saveCookie(currentConfig)}finally{_this.config$.next(currentConfig)}}))()}emitMoveAnnotation(event){this.annotationMove$.next(event)}emitAnnotation(event){this.annotationEvent$.next(event)}emitPlotband(event){this.plotBandEvent$.next(event)}emitPlotline(event){this.plotLineMove$.next(event)}emitPoint(event){this.pointMove$.next(event)}emitChartClick(event){this.chartClick$.next(event)}emitChartContextMenu(event){this.chartContextMenu$.next(event)}saveCookie(config){if(!config.name)return;const hiddenSeries=config.series?.filter((_=>!_.visible)).map((_=>_.id));localStorage.setItem(`${config.name}_${ChartService_1._hiddenSeriesPostfix}`,JSON.stringify(hiddenSeries))}restoreLocalStorage(config){if(!config.name)return config;const hiddenSeries=localStorage.getItem(`${config.name}_${ChartService_1._hiddenSeriesPostfix}`);if(hiddenSeries){const json=JSON.parse(hiddenSeries);return config.series=config.series.map(((serie,index)=>{serie.visible=!json.includes(serie.id);const currentSerieIndex=config.series.findIndex((_=>_.id===serie.id));if(-1!==currentSerieIndex){const seriesLinkCount=config.series.filter((_=>_.yAxisIndex===config.series[currentSerieIndex].yAxisIndex&&!0===_.visible)).length;config.yAxis[config.series[currentSerieIndex].yAxisIndex].visible=0!==seriesLinkCount}return serie})),config}return config}setDefaults(data){let[config,id]=data;const defaultConfig=defaultConfig=>source=>Object.assign({},defaultConfig,source);config=Object.assign({},defaultChartConfig(),config),config.id=config.id??id,config.xAxis=config.xAxis.map(defaultConfig(defaultAxisConfig)),config.yAxis=config.yAxis.map(defaultConfig(defaultAxisConfig)),config.series=config.series.map(defaultConfig({data:[],type:SeriesType.line,xAxisIndex:0,yAxisIndex:0,fillType:FillType.default,color:"coral",visible:!0,clipPointsDirection:ClipPointsDirection.x})),config.series=config.series.map(((_,index)=>({..._,data:_.data??[],id:_.id??index})));const oppositeYCount=config.yAxis?.filter((_=>_.opposite)),oppositeXCount=config.xAxis?.filter((_=>_.opposite)),nonOppositeYCount=config.yAxis?.filter((_=>!_.opposite)),nonOppositeXCount=config.xAxis?.filter((_=>!_.opposite));return nonOppositeXCount?.length>1&&(config.bounds.bottom=0),oppositeXCount?.length>1&&(config.bounds.top=0),nonOppositeYCount?.length>1&&(config.bounds.left=0),oppositeYCount?.length>1&&(config.bounds.right=0),config.tooltip=Object.assign({},defaultChartConfig().tooltip,config.tooltip),config.zoom=Object.assign({},defaultChartConfig().zoom,config.zoom),config.zoom.syncChannel=config.zoom?.syncChannel??id,config}setPreparationData(config){if(config.inverted){const xAxes=[...config.xAxis],yAxes=[...config.yAxis];config.xAxis=yAxes,config.yAxis=xAxes,config.series=config.series?.map((serie=>{const x=serie.xAxisIndex,y=serie.yAxisIndex;return serie.xAxisIndex=y,serie.yAxisIndex=x,{...serie,clipPointsDirection:ClipPointsDirection.y,data:serie?.data?.map((point=>({...point,x:point?.y,y:point?.x,x1:point?.y1,y1:point?.x1})))}}))}return config?.brush?.enable&&(config.yAxis=config.yAxis.map((_=>({..._,zoom:!1}))),config.xAxis=config.xAxis.map((_=>({..._,zoom:!1})))),config}})._hiddenSeriesPostfix="hidden_series",chart_service_class.ctorParameters=()=>[],ChartService_1=chart_service_class);ChartService=ChartService_1=(0,tslib_es6.gn)([(0,core.Injectable)({providedIn:"root"})],ChartService);var AxisOrientation,src=__webpack_require__("./node_modules/d3/src/index.js"),combineLatest=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js");!function(AxisOrientation){AxisOrientation[AxisOrientation.x=0]="x",AxisOrientation[AxisOrientation.y=1]="y"}(AxisOrientation||(AxisOrientation={}));const getTextWidth=(inputText,backupRatio=.5,fontSize=10)=>{let text=inputText??"";return text=text.toString(),fontSize*backupRatio*text.length};function generateTicks(extremes,count=10){const[min,max]=extremes,tickStep=(max-min)/count;return src.w6H(min,max+tickStep,tickStep).filter((step=>step<=max))}class AxisSizeBuilder{constructor(){this.titlePadding=11,this.basePadding=16,this.backupRatio=.58}build(settings){let finalPadding=this.basePadding;if(settings.orientation===AxisOrientation.y){const formatter=settings.options.tickFormat||settings.defaultFormatter();finalPadding+=settings.options.title?this.titlePadding:0;const scale=settings.defaultScale()();scale.domain(settings.extremes),settings.options.scaleType.type===ScaleType.band&&(scale.ticks=ticks=>scale.domain());const ticks=scale.ticks(20),maxElementLengthIndex=function maxIndex(values,valueof){let max,maxIndex=-1,index=-1;if(void 0===valueof)for(const value of values)++index,null!=value&&(max<value||void 0===max&&value>=value)&&(max=value,maxIndex=index);else for(let value of values)null!=(value=valueof(value,++index,values))&&(max<value||void 0===max&&value>=value)&&(max=value,maxIndex=index);return maxIndex}(ticks,(_=>formatter(_).length));finalPadding+=getTextWidth(formatter(ticks[maxElementLengthIndex]),this.backupRatio)}return settings.orientation===AxisOrientation.x&&(finalPadding+=finalPadding+20),finalPadding}}class ExtremesBuilder{constructor(){this.extentAccessorMap=(new Map).set(AxisOrientation.x,(_=>_.x)).set(AxisOrientation.y,(_=>_.y)),this.extremes=[0,1]}build(settings){const options=settings.options;let extremes=[];const hasMin=null!=options?.min,hasMax=null!=options?.max;if(!hasMin||!hasMax){const data=settings.linkedSeries().reduce(((acc,current)=>acc.concat(current.data)),[]),accessor=this.extentAccessorMap.get(settings.orientation);extremes=settings.options.scaleType.type===ScaleType.band?data.map(accessor):data.length>0?src.Wem(data,accessor):[0,1]}return hasMin&&(extremes[0]=options?.min),hasMax&&(extremes[1]=options?.max),"number"==typeof extremes[0]&&"number"==typeof extremes[1]&&extremes[0]===extremes[1]&&(extremes[0]=extremes[0]-1,extremes[1]=extremes[1]+1),this.extremes=extremes,this.extremes}}class Axis{constructor(config){this._extremes=[0,0],this._originDomain=[0,0],this.defaultFormatters=(new Map).set(ScaleType.linear,src.WUZ(",.5~r")).set(ScaleType.time,src.i$Z("%d.%m.%Y")).set(ScaleType.log,src.WUZ("~s")).set(ScaleType.symlog,src.WUZ("~s")).set(ScaleType.pow,src.WUZ("~s")).set(ScaleType.sqrt,src.WUZ("~s")).set(ScaleType.band,(_=>_)),this.defaultScales=(new Map).set(ScaleType.linear,src.BYU).set(ScaleType.log,src.p2C).set(ScaleType.symlog,src.eh9).set(ScaleType.pow,src.vY$).set(ScaleType.sqrt,src.PUr).set(ScaleType.time,src.Xf).set(ScaleType.band,src.tiA),this.chartConfig=config}static createAxis(orientation,config,index){const axis=new Axis(config);return axis.setLocate(orientation),axis.setIndex(index),axis.setOptions(),axis.setExtremes(),axis.setTicksValues(),axis.setSelfSize(),axis}setLocate(orientation){this._orientation=orientation}setIndex(index){this._index=index}linkedSeries(){return this.chartConfig?.series.filter((serie=>serie[this._orientation===AxisOrientation.y?"yAxisIndex":"xAxisIndex"]===this._index))}setExtremes(){const builder=new ExtremesBuilder;this._extremes=builder.build(this)}setOriginDomain(domain){this._originDomain=domain}setScale(scale){this._scale=scale,this.options.scaleType.type===ScaleType.band&&(this._scale.ticks=()=>this._scale.domain())}setSelfSize(){this._selfSize=(new AxisSizeBuilder).build(this)}setTicksValues(){}setOptions(){const options=this.orientation===AxisOrientation.x?this.chartConfig.xAxis[this.index]:this.chartConfig.yAxis[this.index];this._options=options}get scale(){return this._scale}get extremes(){return this._extremes}get orientation(){return this._orientation}get selfSize(){return this._selfSize}get tickValues(){return this._ticksValues}get index(){return this._index}get options(){return this._options}get originDomain(){return this._originDomain}defaultFormatter(){return this.defaultFormatters.get(this.options.scaleType.type)}defaultScale(){return this.defaultScales.get(this.options.scaleType.type)}}class ZoomMessage{constructor(options){this.eventType=options?.eventType,this.element=options?.element,this.axis=options?.axis,this.domain=options.domain,this.chartId=options?.chartId,this.style=options?.style}}class BrushMessage{constructor(options){this.chartId=options?.chartId,this.selection=options?.selection,this.mode=options?.mode}}var broadcast_service_class;let BroadcastService=((broadcast_service_class=class BroadcastService{constructor(){this.zoomEmitter=new ReplaySubject.t(1)}broadcastZoom(value){this.zoomEmitter.next(value)}subscribeToZoom(channel){return this.zoomEmitter.asObservable().pipe((0,filter.h)((msg=>channel&&msg.channel===channel)))}}).ctorParameters=()=>[],broadcast_service_class);var zoom_service_class;BroadcastService=(0,tslib_es6.gn)([(0,core.Injectable)({providedIn:"root"})],BroadcastService);let ZoomService=((zoom_service_class=class ZoomService{constructor(_broadcast,_chart){this._broadcast=_broadcast,this._chart=_chart,this.zoomed$=new BehaviorSubject.X(null),this.zoomed=this.zoomed$.asObservable().pipe((0,shareReplay.d)({bufferSize:1,refCount:!0}))}fireZoom(zoom){this.zoomed$.next(zoom)}broadcastZoom(zoom){this.broadcastChannel?.length&&this._broadcast.broadcastZoom({channel:this.broadcastChannel,message:zoom})}setBroadcastChannel(channel){this.broadcastSub&&this.broadcastSub?.unsubscribe(),this.broadcastChannel=channel,this.broadcastChannel?.length&&(this.broadcastSub=(0,combineLatest.a)([this._broadcast.subscribeToZoom(this.broadcastChannel),this._chart.config]).pipe((0,filter.h)((([zoom,config])=>zoom.message?.chartId!==config.id&&(config.zoom.syncType===ZoomType.xy||zoom.message.axis.orientation===AxisOrientation.y&&config.zoom.syncType===ZoomType.y||zoom.message.axis.orientation===AxisOrientation.x&&config.zoom.syncType===ZoomType.x)))).subscribe((([zoom,config])=>{this.fireZoom(zoom.message)})))}getD3Transform(targetDomain,originalDomain,scale,orientation,inverted){const zoomScale=Math.abs(scale(originalDomain[1])-scale(originalDomain[0]))/Math.abs(scale(targetDomain[1])-scale(targetDomain[0]));let transform=src.CRH.scale(zoomScale);return orientation===AxisOrientation.x&&(transform=inverted?transform.translate(-scale(Math.max(...targetDomain)),0):transform.translate(-scale(Math.min(...targetDomain)),0)),orientation===AxisOrientation.y&&(transform=inverted?transform.translate(0,-scale(Math.min(...targetDomain))):transform.translate(0,-scale(Math.max(...targetDomain)))),transform}ngOnDestroy(){this.broadcastSub?.unsubscribe()}}).ctorParameters=()=>[{type:BroadcastService},{type:ChartService}],zoom_service_class);var scale_service_class;ZoomService=(0,tslib_es6.gn)([(0,core.Injectable)({providedIn:"root"})],ZoomService);let ScaleService=((scale_service_class=class ScaleService{constructor(chartService,zoomService){this.chartService=chartService,this.zoomService=zoomService,this.transformCacheX=new Map,this.transformCacheY=new Map,this.scaleMapping=(new Map).set(ScaleType.linear,src.BYU).set(ScaleType.time,src.Xf).set(ScaleType.log,src.p2C).set(ScaleType.symlog,src.eh9).set(ScaleType.pow,src.vY$).set(ScaleType.sqrt,src.PUr).set(ScaleType.band,src.tiA),this.scales=(0,combineLatest.a)([this.chartService.size,this.chartService.config,this.zoomService.zoomed]).pipe((0,map.U)((data=>{const[size,config,zoom]=data,xAxisMap=new Map,yAxisMap=new Map;config.yAxis.map(((_,index)=>{yAxisMap.set(index,Axis.createAxis(AxisOrientation.y,config,index))})),config.xAxis.map(((_,index)=>{xAxisMap.set(index,Axis.createAxis(AxisOrientation.x,config,index))}));const left=Array.from(yAxisMap.values()).filter((_=>_.options?.visible&&_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),right=Array.from(yAxisMap.values()).filter((_=>_.options?.visible&&!0!==_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),finalWidth=(size.width||0)-left-right;if(xAxisMap.forEach((axis=>{let domain=axis.extremes;axis?.options.inverted&&(domain=[...axis.extremes].reverse());const scale=this.scaleMapping.get(axis.options.scaleType.type)().domain(domain).range([0,finalWidth-config.bounds.right]);axis.options.niceTicks&&scale.nice(),axis.options.scaleType.type===ScaleType.log&&scale.base(axis.options.scaleType.base),axis.options.scaleType.type===ScaleType.band&&(scale.paddingInner(.1),scale.paddingOuter(.1),scale.align(.1)),axis.setScale(scale),axis.setOriginDomain(scale.domain());const hasCache=this.transformCacheX.has(axis.index),shouldRestore=zoom?.axis?.orientation!==AxisOrientation.x||zoom.axis?.index!==axis.index;if(hasCache&&shouldRestore){const restoredTransform=this.transformCacheX.get(axis.index);axis.setScale(restoredTransform.rescaleX(scale))}})),zoom&&zoom.domain&&zoom.axis?.orientation===AxisOrientation.x&&xAxisMap.has(zoom.axis.index)){const x=xAxisMap.get(zoom.axis.index),transform=this.zoomService.getD3Transform(zoom.domain,x.originDomain,x.scale,AxisOrientation.x,x.options.inverted),rescaled=transform.rescaleX(x.scale.copy());x.setScale(rescaled),this.transformCacheX.set(x.index,transform)}const top=Array.from(xAxisMap.values()).filter((_=>_.options?.visible&&_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),bottom=Array.from(xAxisMap.values()).filter((_=>_.options?.visible&&!0!==_.options?.opposite)).reduce(((acc,cur)=>acc+cur.selfSize),0),finalHeight=(size.height||0)-top-bottom-config?.bounds?.top-config.bounds?.bottom;if(yAxisMap.forEach((axis=>{let domain=axis.extremes;axis.orientation===AxisOrientation.y&&(domain=[...axis.extremes].reverse()),axis?.options.inverted&&(domain=domain.reverse());const scale=this.scaleMapping.get(axis.options.scaleType.type)().domain(domain).range([config.bounds.top,finalHeight]);axis.options.niceTicks&&scale.nice(),axis.options.scaleType.type===ScaleType.log&&scale.base(axis.options.scaleType.base),axis.options.scaleType.type===ScaleType.band&&(scale.paddingInner(.1),scale.paddingOuter(.1),scale.align(.1)),axis.setScale(scale),axis.setOriginDomain(scale.domain());const hasCache=this.transformCacheY.has(axis.index),shouldRestore=zoom?.axis?.orientation!==AxisOrientation.y||zoom.axis?.index!==axis.index;if(hasCache&&shouldRestore){const restoredTransform=this.transformCacheY.get(axis.index);axis.setScale(restoredTransform.rescaleY(scale))}})),zoom&&zoom.domain&&zoom.axis?.orientation===AxisOrientation.y&&yAxisMap.has(zoom.axis.index)){const y=yAxisMap.get(zoom.axis.index),transform=this.zoomService.getD3Transform(zoom.domain,y.originDomain,y.scale,AxisOrientation.y,y.options.inverted),rescaled=transform.rescaleY(y.scale.copy());y.setScale(rescaled),this.transformCacheY.set(y.index,transform)}return{x:xAxisMap,y:yAxisMap}})),(0,shareReplay.d)({bufferSize:1,refCount:!0}))}resetZoom(){this.chartService.config.pipe((0,take.q)(1),(0,withLatestFrom.M)(this.scales)).subscribe((([config,scales])=>{config.xAxis.forEach(((axis,index)=>{const scale=scales?.x?.get(index)?.originDomain;if(scale){const msg=new ZoomMessage({eventType:"end",axis:{index,orientation:AxisOrientation.x},domain:scale,chartId:config.id});this.zoomService.fireZoom(msg),config.zoom.syncChannel&&config.zoom.syncType===ZoomType.x&&this.zoomService.broadcastZoom(msg)}})),config.yAxis.forEach(((axis,index)=>{const scale=scales?.y?.get(index)?.originDomain;if(scale){const msg=new ZoomMessage({eventType:"end",axis:{index,orientation:AxisOrientation.y},domain:scale,chartId:config.id});this.zoomService.fireZoom(msg),config.zoom.syncChannel&&config.zoom.syncType===ZoomType.y&&this.zoomService.broadcastZoom(msg)}}))}))}}).ctorParameters=()=>[{type:ChartService},{type:ZoomService}],scale_service_class);var chart_component_class;ScaleService=(0,tslib_es6.gn)([(0,core.Injectable)({providedIn:"root"})],ScaleService);let ChartComponent=((chart_component_class=class ChartComponent{set config(config){this.chartService.setConfig(config),this.zoomService.setBroadcastChannel(config?.zoom?.syncChannel)}constructor(chartService,zoomService,brushService,scaleService){this.chartService=chartService,this.zoomService=zoomService,this.brushService=brushService,this.scaleService=scaleService,this.pointerMove=new core.EventEmitter,this.plotBandsMove=new core.EventEmitter,this.plotBandClick=new core.EventEmitter,this.plotBandContextMenu=new core.EventEmitter,this.plotLinesMove=new core.EventEmitter,this.pointMove=new core.EventEmitter,this.chartClick=new core.EventEmitter,this.chartContextMenu=new core.EventEmitter,this.annotationContextMenu=new core.EventEmitter,this.annotationClick=new core.EventEmitter,this.annotationMove=new core.EventEmitter,this.zoomServiceInstance=new core.EventEmitter,this.brushServiceInstance=new core.EventEmitter,this._alive=!0,this.svcConfig=this.chartService.config,this.hasSeriesData=this.svcConfig.pipe((0,map.U)((_=>_.series?.length>0&&_.series?.some((_=>_.data?.length>0)))))}resetZoom(){this.scaleService.resetZoom()}ngOnInit(){this.zoomServiceInstance.emit(this.zoomService),this.brushServiceInstance.emit(this.brushService),this.chartService.pointerMove.pipe((0,takeWhile.o)((()=>this._alive)),(0,withLatestFrom.M)(this.scaleService.scales,this.chartService.config)).subscribe((data=>{const[event,{x,y},config]=data,tooltipTracking=config?.tooltip?.tracking;if(tooltipTracking===TooltipTracking.y){const result=new Map;y.forEach(((value,key)=>{value.options.scaleType.type!==ScaleType.band&&result.set(key,value.scale.invert(event.offsetY))})),this.pointerMove.emit({event,target:result})}else{const result=new Map;x.forEach(((value,key)=>{value.options.scaleType.type!==ScaleType.band&&result.set(key,value.scale.invert(event.offsetX))})),this.pointerMove.emit({event,target:result})}})),this.chartService.plotBandEvent.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.plotBandsMove.emit(_)})),this.chartService.plotLineMove.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.plotLinesMove.emit(_)})),this.chartService.pointMove.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.pointMove.emit(_)})),this.chartService.chartClick.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.chartClick.emit(_)})),this.chartService.chartContextMenu.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.chartContextMenu.emit(_)})),this.chartService.plotBandClick.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.plotBandClick.emit(_)})),this.chartService.plotBandContextMenu.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.plotBandContextMenu.emit(_)})),this.chartService.annotationContextMenu.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.annotationContextMenu.emit(_)})),this.chartService.annotationClick.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.annotationClick.emit(_)})),this.chartService.annotationMove.pipe((0,takeWhile.o)((()=>this._alive))).subscribe((_=>{this.annotationMove.emit(_)}))}ngOnDestroy(){this._alive=!1}}).ctorParameters=()=>[{type:ChartService},{type:ZoomService},{type:BrushService},{type:ScaleService}],chart_component_class.propDecorators={pointerMove:[{type:core.Output}],plotBandsMove:[{type:core.Output}],plotBandClick:[{type:core.Output}],plotBandContextMenu:[{type:core.Output}],plotLinesMove:[{type:core.Output}],pointMove:[{type:core.Output}],chartClick:[{type:core.Output}],chartContextMenu:[{type:core.Output}],annotationContextMenu:[{type:core.Output}],annotationClick:[{type:core.Output}],annotationMove:[{type:core.Output}],zoomServiceInstance:[{type:core.Output}],brushServiceInstance:[{type:core.Output}],config:[{type:core.Input}]},chart_component_class);ChartComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"teta-svg-chart",template:'<ng-container *ngIf="{\n  hasSeriesData: hasSeriesData | async,\n  svcConfig: svcConfig | async\n} as data">\n  <ng-container *ngIf="data.hasSeriesData === true else noData">\n    <div class="column column_auto">\n      <teta-chart-container class="chart-container position-relative"></teta-chart-container>\n    </div>\n    <teta-legend *ngIf="data.svcConfig.legend?.enable === true" [series]="data.svcConfig.series"></teta-legend>\n  </ng-container>\n</ng-container>\n<ng-template #noData>\n  <div class="column column_auto justify-content-center">\n    <span class="font-body-3 color-text-40 overflow-hidden text-overflow-ellipsis nowrap text-align-center">\n      <div #ref><ng-content></ng-content></div>\n      <span *ngIf="!ref.hasChildNodes()">\n        No data\n      </span>\n    </span>\n  </div>\n</ng-template>\n',providers:[ChartService,ZoomService,ScaleService,BrushService],changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[chart_componentngResource_default()]})],ChartComponent);var series_base_component_class,common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),tetacom_ng_components=__webpack_require__("./node_modules/@tetacom/ng-components/fesm2022/tetacom-ng-components.mjs");let SeriesBaseComponent=((series_base_component_class=class SeriesBaseComponent{set config(config){this._config=config}get config(){return this._config}set series(series){this._series=series}get series(){return this._series}constructor(svc,cdr,scaleService,zoomService,element,zone){this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.zone=zone}ngOnInit(){}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef},{type:core.NgZone}],series_base_component_class.propDecorators={config:[{type:core.Input}],series:[{type:core.Input}]},series_base_component_class);SeriesBaseComponent=(0,tslib_es6.gn)([(0,core.Component)({template:""})],SeriesBaseComponent);var annotation_component_class,annotation_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/annotation/annotation.component.scss?ngResource"),annotation_componentngResource_default=__webpack_require__.n(annotation_componentngResource);let AnnotationComponent=((annotation_component_class=class AnnotationComponent{set annotation(annotation){this._annotation=annotation}get annotation(){return this._annotation}set node(node){this._node=node,this.init(),this.cdr.detectChanges()}get node(){return this._node}constructor(scaleService,cdr,chartService){this.scaleService=scaleService,this.cdr=cdr,this.chartService=chartService,this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.annotation.xAxisIndex??0)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.annotation.yAxisIndex??0)?.scale))),this.drag=src.ohM()}click(event){this.chartService.emitAnnotation({event,target:this.annotation})}contextMenu(event){this.chartService.emitAnnotation({event,target:this.annotation})}ngOnDestroy(){this.drag.on("drag end",null)}init(){var _this=this;src.Ys(this.node.nativeElement).datum(this.annotation);const nodeRect=this.node.nativeElement.getBoundingClientRect();this.annotation.draggable&&(this.drag.on("drag end",function(){var _ref=(0,asyncToGenerator.Z)((function*(event,d){const x=yield(0,lastValueFrom.n)(_this.x.pipe((0,take.q)(1))),y=yield(0,lastValueFrom.n)(_this.y.pipe((0,take.q)(1)));d.dx+=event.dx,d.dy+=event.dy,d.dx+x(d.point.x)-10<=0&&(d.dx=10-x(d.point.x)),d.dx+x(d.point.x)+nodeRect.width-10>=_this.visibleRect.width&&(d.dx=_this.visibleRect.width-x(d.point.x)-nodeRect.width+10),d.dy+y(d.point.y)-10<=0&&(d.dy=10-y(d.point.y)),d.dy+y(d.point.y)+nodeRect.height-10>=_this.visibleRect.height&&(d.dy=Math.abs(y(d.point.y)-_this.visibleRect.height)-nodeRect.height+10),_this.cdr.detectChanges(),_this.chartService.emitMoveAnnotation({event,target:d})}));return function(_x,_x2){return _ref.apply(this,arguments)}}()),src.Ys(this.node.nativeElement).call(this.drag))}}).ctorParameters=()=>[{type:ScaleService},{type:core.ChangeDetectorRef},{type:ChartService}],annotation_component_class.propDecorators={visibleRect:[{type:core.Input}],annotation:[{type:core.Input}],node:[{type:core.ViewChild,args:["annotationNode",{static:!1}]}],click:[{type:core.HostListener,args:["click",["$event"]]}],contextMenu:[{type:core.HostListener,args:["contextmenu",["$event"]]}]},annotation_component_class);AnnotationComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-annotation]",template:'<ng-container *ngIf="{\n      x: x | async,\n      y: y | async\n    } as data">\n  <ng-container *ngIf="data.x && data.y">\n\n\n    <svg:circle\n      [attr.r]="annotation.style?.radius ?? 5"\n      [attr.cx]="data.x(annotation.point.x)"\n      [attr.fill]="annotation?.style?.fill ?? \'var(--color-text-90)\'"\n      [attr.cy]="data.y(annotation.point.y)">\n    </svg:circle>\n    <svg:line\n      [attr.x1]="data.x(annotation.point.x)"\n      [attr.y1]="data.y(annotation.point.y)"\n      [attr.x2]="data.x(annotation.point.x) + (annotation.dx ?? 0)"\n      [attr.y2]="data.y(annotation.point.y) + (annotation.dy ?? 0)"\n      [attr.stroke]="annotation.style?.stroke ?? \'var(--color-text-90)\'"\n      [attr.stroke-width]="annotation.style?.strokeWidth ?? 1"\n      [attr.stroke-dasharray]="annotation.style?.strokeDasharray ?? null"\n    >\n    </svg:line>\n    <svg:foreignObject\n      class="position-absolute"\n      [attr.width]="node?.nativeElement.offsetWidth ?? 0"\n      [attr.height]="node?.nativeElement.offsetHeight ?? 0"\n      [attr.x]="data.x(annotation.point.x) + (annotation.dx ?? 0) - 10"\n      [attr.y]="data.y(annotation.point.y) + (annotation.dy ?? 0) - 10">\n      <div\n        #annotationNode\n        [style.background-color]="annotation.style?.fill ?? \'var(--color-global-bgmain)\'"\n        [style.cursor]="annotation?.draggable ? \'move\' : \'default\'"\n        [className]="\'padding-h-2 \' + annotation.className ?? \'\'"\n        style="border-radius: 2px; display: inline-block;">\n        <ng-container *ngIf="annotation.template;else default">\n          <ng-container *ngTemplateOutlet="annotation.template;context: {$implicit: annotation}"></ng-container>\n        </ng-container>\n      </div>\n    </svg:foreignObject>\n  </ng-container>\n</ng-container>\n<ng-template #default>\n  {{ annotation.note?.label}}\n</ng-template>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[annotation_componentngResource_default()]})],AnnotationComponent);var BrushType,chart_container_component_class,chart_container_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/chart-container.component.scss?ngResource"),chart_container_componentngResource_default=__webpack_require__.n(chart_container_componentngResource),observeOn=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/observeOn.js"),animationFrame=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js");!function(BrushType){BrushType[BrushType.x=0]="x",BrushType[BrushType.y=1]="y",BrushType[BrushType.xy=2]="xy"}(BrushType||(BrushType={}));let ChartContainerComponent=((chart_container_component_class=class ChartContainerComponent{constructor(_svc,_scaleService,_elementRef,_zone){this._svc=_svc,this._scaleService=_scaleService,this._elementRef=_elementRef,this._zone=_zone,this.zoomType=ZoomType,this.filterPositionMap=(new Map).set(!0,(axis=>_=>_.options.opposite&&_.options.visible&&axis.index<=_.index)).set(!1,(axis=>_=>!0!==_.options.opposite&&_.options.visible&&_.index<=axis.index)),this.sumSize=(acc,curr)=>acc+curr.selfSize,this.config=this._svc.config,this.size=this._svc.size,this.scales=this._scaleService.scales.pipe((0,observeOn.Q)(animationFrame.Z),(0,tetacom_ng_components.luZ)(this._zone),(0,shareReplay.d)({bufferSize:1,refCount:!0})),this.plotBands=(0,combineLatest.a)([this.config,this.scales]).pipe((0,map.U)((([config,scales])=>{const bands=[];return config.xAxis?.forEach(((axis,index)=>{axis.plotBands?.forEach((band=>{bands.push({plotBand:band,axis:scales.x.get(index)})}))})),config.yAxis?.forEach(((axis,index)=>{axis.plotBands?.forEach((band=>{bands.push({plotBand:band,axis:scales.y.get(index)})}))})),bands.sort(((a,b)=>a.plotBand.order-b.plotBand.order))}))),this.brushScale=this._scaleService.scales.pipe((0,withLatestFrom.M)(this.config),(0,map.U)((data=>{const[{x,y},config]=data;return config.brush?.type===BrushType.x||config?.zoom?.type===ZoomType.x?x.get(0)?.scale:y.get(0)?.scale})),(0,shareReplay.d)({bufferSize:1,refCount:!0})),this.visibleRect=(0,combineLatest.a)([this.size,this.scales,this.config]).pipe((0,map.U)((data=>{const[size,{x,y},config]=data,yAxesArray=Array.from(y.values()),xAxesArray=Array.from(x.values()),left=yAxesArray.filter((_=>!0!==_.options.opposite&&_.options.visible)).reduce(this.sumSize,0),right=yAxesArray.filter((_=>_.options.opposite&&_.options.visible)).reduce(this.sumSize,0),bottom=xAxesArray.filter((_=>!0!==_.options.opposite&&_.options.visible)).reduce(this.sumSize,0),top=xAxesArray.filter((_=>_.options.opposite&&_.options.visible)).reduce(this.sumSize,0);return{x:left+config.bounds?.left,y:top+config.bounds?.top,width:size.width-left-right-config.bounds?.left-config.bounds?.right,height:size.height-top-bottom-config.bounds?.top-config.bounds?.bottom}})),(0,tetacom_ng_components.luZ)(this._zone),(0,shareReplay.d)({bufferSize:1,refCount:!0}))}ngAfterViewInit(){this._observer=new ResizeObserver((entries=>{requestAnimationFrame((()=>{!Array.isArray(entries)||!entries.length||entries[0].contentRect.width<=0||entries[0].contentRect.height<=0||this._svc.setSize(entries[0].contentRect)}))})),this._observer.observe(this._elementRef.nativeElement)}ngOnDestroy(){this._observer.unobserve(this._elementRef.nativeElement),this._observer.disconnect()}getTranslate(axis,size){return this.scales.pipe((0,withLatestFrom.M)(this.config),(0,map.U)((data=>{const[{x,y},config]=data,xAxesArray=Array.from(x.values()),yAxesArray=Array.from(y.values()),oppositeFilter=this.filterPositionMap.get(!0),nonOppositeFilter=this.filterPositionMap.get(!1),oppositeOffsetY=yAxesArray.filter(oppositeFilter(axis)),nonOppositeOffsetY=yAxesArray.filter(nonOppositeFilter(axis)),oppositeOffsetX=xAxesArray.filter(oppositeFilter(axis)),nonOppositeOffsetX=xAxesArray.filter(nonOppositeFilter(axis)),oppositeTranslateY=oppositeOffsetY.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.right),nonOppisteTranslateY=nonOppositeOffsetY.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.left),oppositeTranslateX=oppositeOffsetX.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.top),nonOppisteTranslateX=nonOppositeOffsetX.reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.bottom),left=yAxesArray.filter((_=>_.options.visible&&!0!==_.options.opposite)).reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.left),top=xAxesArray.filter((_=>_.options.visible&&!0===_.options.opposite)).reduce(((acc,curr)=>acc+curr.selfSize),config.bounds?.top);return axis.orientation===AxisOrientation.x?`translate(${left}, ${axis.options.opposite?oppositeTranslateX:size.height-nonOppisteTranslateX})`:axis.orientation===AxisOrientation.y?`translate(${axis.options.opposite?size.width-oppositeTranslateY:nonOppisteTranslateY}, ${top})`:"translate(0, 0)"})))}identify(index,item){return item.value.index}click(event,xScales,yScales){const x=xScales.get(0)?.scale,y=yScales.get(0)?.scale;this._svc.emitChartClick({event,target:{x:x.invert(event.offsetX),y:y.invert(event.offsetY)}})}contextMenu(event,xScales,yScales){const x=xScales.get(0)?.scale,y=yScales.get(0)?.scale;this._svc.emitChartContextMenu({event,target:{x:x.invert(event.offsetX),y:y.invert(event.offsetY)}})}mouseMove(event){this._svc.setPointerMove(event)}mouseLeave(event){this._svc.setPointerMove(event)}trackSerie(index,item){return item.name?.length?item.name:index}}).ctorParameters=()=>[{type:ChartService},{type:ScaleService},{type:core.ElementRef},{type:core.NgZone}],chart_container_component_class);ChartContainerComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"teta-chart-container",template:'<ng-container *ngIf="{\n  size: size | async,\n  config: config | async,\n  scales: scales | async,\n  plotBands: plotBands | async,\n  visibleRect: visibleRect | async\n} as data" xmlns:svg="http://www.w3.org/1999/html">\n  <teta-tooltip *ngIf="data.config?.tooltip?.enable"\n                [size]="data.size"\n                [config]="data.config"></teta-tooltip>\n  <ng-container *ngIf="data.size?.height > 0\n                      && data.size?.width > 0\n                      && data.visibleRect?.height > 0\n                      && data.visibleRect?.width > 0\n                      && data.scales?.x.size === data.config.xAxis.length\n                      && data.scales?.y.size === data.config.yAxis.length">\n    <svg height="100%" width="100%" class="position-absolute">\n      <g class="y-axis-container">\n        <ng-container *ngFor="let item of data.scales.y | keyvalue; trackBy: identify">\n          <ng-container *ngIf="item.value.selfSize > 0\n                                && item.value.options.visible\n                                && data.scales.x.size > 0\n                                && data.scales.y.size > 0">\n            <g\n              teta-y-axis\n              [axis]="item.value"\n              [size]="data.visibleRect"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></g>\n            <rect\n              tetaZoomable\n              fill-opacity="0"\n              [axis]="item.value"\n              [config]="data.config"\n              [size]="data.visibleRect"\n              [attr.x]="item.value.options.opposite ? 0 : -item.value.selfSize"\n              [attr.y]="0"\n              [attr.height]="data.visibleRect.height"\n              [attr.width]="item.value.selfSize"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></rect>\n          </ng-container>\n\n        </ng-container>\n      </g>\n      <g class="x-axis-container">\n        <ng-container *ngFor="let item of data.scales.x | keyvalue; trackBy: identify">\n          <ng-container *ngIf="item.value.options.visible && data.scales.x.size > 0 && data.scales.y.size > 0">\n            <g\n              teta-x-axis\n              [axis]="item.value"\n              [size]="data.visibleRect"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></g>\n            <rect\n              tetaZoomable\n              fill-opacity="0"\n              [axis]="item.value"\n              [config]="data.config"\n              [size]="data.visibleRect"\n              [attr.x]="0"\n              [attr.y]="item.value.options.opposite ? -item.value.selfSize : 0"\n              [attr.width]="data.visibleRect.width"\n              [attr.height]="item.value.selfSize"\n              [attr.transform]="getTranslate(item.value, data.size) | async"></rect>\n          </ng-container>\n        </ng-container>\n      </g>\n    </svg>\n  </ng-container>\n  <ng-container\n    *ngIf="data.size?.height > 0\n          && data.size?.width > 0\n          && data.visibleRect?.height > 0\n          && data.visibleRect?.width > 0\n          && data.scales?.x.size === data.config.xAxis.length\n          && data.scales?.y.size === data.config.yAxis.length">\n    <svg\n      tetaZoomable\n      tetaBrushable\n      class="position-absolute"\n      [size]="data.visibleRect"\n      [config]="data.config"\n      [axis]="data.config?.zoom?.type === zoomType.x ? data.scales.x.get(0) : data.scales.y.get(0)"\n      [attr.width]="data.visibleRect.width"\n      [attr.height]="data.visibleRect.height"\n      [attr.viewBox]="\'0 0 \' + data.visibleRect.width + \' \' + data.visibleRect.height"\n      [style.transform]="\'translate(\'+ data.visibleRect.x +\'px, \'+ data.visibleRect.y +\'px)\'"\n      (contextmenu)="contextMenu($event, data.scales.x, data.scales.y)"\n      (click)="click($event, data.scales.x, data.scales.y)"\n      (mouseleave)="mouseLeave($event)"\n      (mousemove)="mouseMove($event)">\n      <g class="gridlines"\n         teta-gridlines\n         *ngIf="data.config.gridLines?.enable !== false"\n         [size]="data.size"></g>\n      <g class="x-axis-plotband-container">\n          <g teta-plot-band *ngFor="let plotBand of data.plotBands"\n             [plotBand]="plotBand.plotBand"\n             [scale]="plotBand.axis.scale"\n             [size]="data.visibleRect"\n             [axis]="plotBand.axis"></g>\n      </g>\n      <g class="series-container">\n        <ng-container *ngFor="let series of data.config.series;">\n          <g teta-series-host\n             *ngIf="series.visible"\n             [config]="data.config"\n             [series]="series"></g>\n        </ng-container>\n      </g>\n      <g class="x-axis-plotline-container">\n        <ng-container *ngFor="let axis of data.config.xAxis; let i = index">\n          <g teta-plot-line *ngFor="let plotLine of axis.plotLines"\n             [plotLine]="plotLine"\n             [scale]="data.scales.x.get(i).scale"\n             [size]="data.size"\n             [axis]="data.scales.x.get(i)"></g>\n        </ng-container>\n      </g>\n      <g class="y-axis-plotline-container">\n        <ng-container *ngFor="let axis of data.config.yAxis; let i = index">\n          <g teta-plot-line *ngFor="let plotLine of axis.plotLines"\n             [plotLine]="plotLine"\n             [scale]="data.scales.y.get(i).scale"\n             [size]="data.size"\n             [axis]="data.scales.y.get(i)"></g>\n        </ng-container>\n      </g>\n      <g class="annotations">\n        <g teta-annotation\n           [visibleRect]="data.visibleRect"\n           *ngFor="let annotation of data.config.annotations"\n           [annotation]="annotation"></g>\n      </g>\n      <g class="crosshair" *ngIf="data.config.tooltip?.showCrosshair">\n        <g teta-crosshair [size]="data.visibleRect"></g>\n      </g>\n    </svg>\n  </ng-container>\n</ng-container>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[chart_container_componentngResource_default()]})],ChartContainerComponent);var crosshair_component_class,crosshair_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/crosshair/crosshair.component.scss?ngResource"),crosshair_componentngResource_default=__webpack_require__.n(crosshair_componentngResource),tap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/tap.js");let CrosshairComponent=((crosshair_component_class=class CrosshairComponent{constructor(scaleService,chartService,cdr){this.scaleService=scaleService,this.chartService=chartService,this.cdr=cdr}ngOnInit(){this.transform=this.chartService.pointerMove.pipe((0,map.U)((event=>({x:"mouseleave"===event.type?-9999:event.offsetX,y:"mouseleave"===event.type?-9999:event.offsetY}))),(0,tap.b)((()=>{setTimeout((()=>{this.cdr.detectChanges()}))})))}}).ctorParameters=()=>[{type:ScaleService},{type:ChartService},{type:core.ChangeDetectorRef}],crosshair_component_class.propDecorators={size:[{type:core.Input}]},crosshair_component_class);CrosshairComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-crosshair]",template:'<ng-container *ngIf="transform | async as t">\n  <svg:line [attr.x1]="t.x" y1="0" [attr.x2]="t.x" [attr.y2]="size.height" stroke="var(--color-text-90)" stroke-width="0.5"></svg:line>\n  <svg:line x1="0" [attr.y1]="t.y" [attr.x2]="size.width" [attr.y2]="t.y" stroke="var(--color-text-90)" stroke-width="0.5"></svg:line>\n</ng-container>\n',styles:[crosshair_componentngResource_default()]})],CrosshairComponent);var gridlines_component_class,gridlines_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/gridlines/gridlines.component.scss?ngResource"),gridlines_componentngResource_default=__webpack_require__.n(gridlines_componentngResource);let GridlinesComponent=((gridlines_component_class=class GridlinesComponent{constructor(svc,chartService){this.svc=svc,this.chartService=chartService,this.config=this.chartService.config,this.tickYValues=this.svc.scales.pipe((0,withLatestFrom.M)(this.config),(0,map.U)((_=>{const[scales,config]=_,ratio=this.size.height/40;return null!=config.gridLines?.y?.ticksCount?generateTicks(scales.y.get(0).scale.domain(),config.gridLines?.y?.ticksCount):scales.y.get(0)?.scale.ticks(ratio)}))),this.tickXValues=this.svc.scales.pipe((0,withLatestFrom.M)(this.config),(0,map.U)((_=>{const[scales,config]=_,ratio=this.size.width/40;return null!=config.gridLines?.x?.ticksCount?generateTicks(scales.x.get(0).originDomain,config.gridLines?.x?.ticksCount):scales.x.get(0)?.scale.ticks(ratio)}))),this.y=this.svc.scales.pipe((0,map.U)((_=>_.y.get(0)?.scale))),this.x=this.svc.scales.pipe((0,map.U)((_=>_.x.get(0)?.scale)))}ngAfterViewInit(){}}).ctorParameters=()=>[{type:ScaleService},{type:ChartService}],gridlines_component_class.propDecorators={size:[{type:core.Input}]},gridlines_component_class);GridlinesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-gridlines]",template:'<ng-container *ngIf="{\n  xValues: tickXValues | async,\n  yValues: tickYValues | async,\n  x: x | async,\n  y: y | async,\n  config: config | async\n} as data">\n  <ng-container *ngIf="data.y && data.config.gridLines?.showY !== false">\n    <ng-container *ngFor="let tick of data.yValues">\n      <svg:line [attr.x1]="0"\n                [attr.y1]="data.y(tick) || 1"\n                [attr.x2]="size?.width"\n                [attr.y2]="data.y(tick) || 1"></svg:line>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngIf="data.x && data.config.gridLines?.showX !== false">\n    <ng-container *ngFor="let tick of data.xValues">\n      <svg:line [attr.x1]="data.x(tick) || 1"\n                [attr.y1]="0"\n                [attr.x2]="data.x(tick) || 1"\n                [attr.y2]="size?.height"></svg:line>\n    </ng-container>\n  </ng-container>\n\n</ng-container>\n\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[gridlines_componentngResource_default()]})],GridlinesComponent);var plot_band_component_class,plot_band_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/plotband/plot-band.component.scss?ngResource"),plot_band_componentngResource_default=__webpack_require__.n(plot_band_componentngResource);let PlotBandComponent=((plot_band_component_class=class PlotBandComponent{click(event){this.emit({target:this.plotBand,event})}contextMenu(event){this.emit({target:this.plotBand,event})}get height(){return this.size.height}get width(){return this.size.width}get from(){return this.scale(this.plotBand.from)}get to(){return this.scale(this.plotBand.to)}get bandSize(){return Math.abs(this.scale(this.plotBand.to)-this.scale(this.plotBand.from))}constructor(chartService,cdr,element){this.chartService=chartService,this.cdr=cdr,this.element=element,this.orientation=AxisOrientation,this.getTextPosition=()=>{let[min,max]=this.scale.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max;const from=this.plotBand.from instanceof Date?this.plotBand.from.getTime():this.plotBand.from,to=this.plotBand.to instanceof Date?this.plotBand.to.getTime():this.plotBand.to,position=((from<=min?min:from)+(to>=max?max:to))/2;return this.scale(position)}}emit(event){this.chartService.emitPlotband(event)}ngAfterViewInit(){const plotbandElement=src.Ys(this.element.nativeElement).select(".plotband"),grabElements=src.Ys(this.element.nativeElement).selectAll(".grabber");this.dragElements=src.ohM().subject((()=>this.axis.orientation===AxisOrientation.x?{x:plotbandElement.attr("x")}:this.axis.orientation===AxisOrientation.y?{y:plotbandElement.attr("y")}:void 0));const drag=this.dragElements.on("start drag end",((event,d)=>{const bandSize=parseFloat(plotbandElement.attr(this.axis.orientation===AxisOrientation.x?"width":"height"));d.from=this.scale.invert(event[AxisOrientation[this.axis.orientation]]),d.to=this.scale.invert(event[AxisOrientation[this.axis.orientation]]+bandSize),this.emit({event,target:d}),this.cdr.detectChanges()}));let grabberKey;this.resizeElements=src.ohM();const resize=this.resizeElements.on("start drag end",((event,d)=>{if("start"===event?.type){const{grabber}=event?.sourceEvent?.target?.dataset;grabberKey=grabber}const min=Math.min(...this.scale.domain()),max=Math.max(...this.scale.domain()),minValue=d.min??min,maxValue=d.max??max;if(d[grabberKey]=this.scale.invert(event[AxisOrientation[this.axis.orientation]]),"from"===grabberKey){const borderMin=d.from<=minValue;d.from>=d.to&&(d.from=d.to),borderMin&&(d.from=minValue)}if("to"===grabberKey){d.to>=maxValue&&(d.to=maxValue),d.to<=d.from&&(d.to=d.from)}this.emit({event,target:d}),this.cdr.detectChanges()}));plotbandElement.datum(this.plotBand),grabElements.datum(this.plotBand),this.plotBand.draggable&&plotbandElement.call(drag),this.plotBand.resizable&&grabElements.call(resize)}ngOnDestroy(){this.dragElements.on("start drag end",null),this.resizeElements.on("start drag end",null)}getFill(d){return d.style?.plotBand?.patternImage?`url(#${d.style.plotBand?.patternImage})`:d.style.plotBand?.fill}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:core.ElementRef}],plot_band_component_class.propDecorators={plotBand:[{type:core.Input}],axis:[{type:core.Input}],scale:[{type:core.Input}],size:[{type:core.Input}],click:[{type:core.HostListener,args:["click",["$event"]]}],contextMenu:[{type:core.HostListener,args:["contextmenu",["$event"]]}]},plot_band_component_class);PlotBandComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-plot-band]",template:"<svg:rect\n  class='plotband' xmlns:svg='http://www.w3.org/1999/html'\n  [class.draggable]='plotBand?.draggable === true'\n  [attr.fill]='getFill(plotBand)'\n  [attr.opacity]='plotBand.style?.plotBand?.opacity'\n  [attr.height]='axis.orientation === orientation.x ? height : bandSize'\n  [attr.width]='axis.orientation === orientation.x ? bandSize : width'\n  [attr.y]='axis.orientation === orientation.y ? (axis.options.inverted === true ? from : to) : null'\n  [attr.x]='axis.orientation === orientation.x ? (axis.options.inverted === true ? to : from) : null'>\n</svg:rect>\n<svg:text\n  *ngIf='axis.orientation === orientation.x'\n  text-anchor='middle'\n  dominant-baseline='middle'\n  class='label font-caption fill-text-90'\n  [attr.x]='getTextPosition()'\n  [attr.transform]=\"'rotate(-90, '+ getTextPosition() +',' + height / 2 + ')'\"\n  [attr.y]='height / 2'>{{plotBand.label}}\n</svg:text>\n<svg:text\n  *ngIf='axis.orientation === orientation.y'\n  text-anchor='middle'\n  class='label font-caption fill-text-90'\n  dominant-baseline='central'\n  [attr.x]='getTextPosition()'\n  [attr.y]='width / 2'>{{plotBand.label}}\n</svg:text>\n<ng-container *ngIf='plotBand.resizable'>\n  <ng-container *ngIf='plotBand.showGrabbers'>\n    <svg:line class='display-grabber'\n              [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n              [attr.stroke-width]='plotBand.style?.grabbers?.strokeWidth || 4'\n              [attr.stroke-dasharray]='plotBand.style?.grabbers?.strokeDasharray'\n              [attr.x1]='axis.orientation === orientation.x ? from : 0'\n              [attr.x2]='axis.orientation === orientation.x ? from : width'\n              [attr.data-grabber]=\"'from'\"\n              [attr.y1]='axis.orientation === orientation.x ? 0 : from'\n              [attr.y2]='axis.orientation === orientation.x ? height : from'>\n    </svg:line>\n    <svg:line class='display-grabber'\n              [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n              [attr.stroke-width]='plotBand.style?.grabbers?.strokeWidth || 4'\n              [attr.stroke-dasharray]='plotBand.style?.grabbers?.strokeDasharray'\n              [attr.x1]='axis.orientation === orientation.x ? to : 0'\n              [attr.x2]='axis.orientation === orientation.x ? to : width'\n              [attr.data-grabber]=\"'to'\"\n              [attr.y1]='axis.orientation === orientation.x ? 0 : to'\n              [attr.y2]='axis.orientation === orientation.x ? height : to'>\n    </svg:line>\n  </ng-container>\n  <svg:line class='grabber'\n            [class.x-grabber]='axis.orientation === orientation.x'\n            [class.y-grabber]='axis.orientation === orientation.y'\n            [class.resizeable]='plotBand?.resizable'\n            [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n            [attr.stroke-width]='8'\n            [style.transform]=\"axis.orientation === orientation.x ? 'translateX(2px)' : 'translateY(2px)'\"\n            [attr.x1]='axis.orientation === orientation.x ? from : 0'\n            [attr.x2]='axis.orientation === orientation.x ? from : width'\n            [attr.data-grabber]=\"'from'\"\n            [attr.y1]='axis.orientation === orientation.x ? 0 : from'\n            [attr.y2]='axis.orientation === orientation.x ? height : from'>\n  </svg:line>\n  <svg:line class='grabber'\n            [class.x-grabber]='axis.orientation === orientation.x'\n            [class.y-grabber]='axis.orientation === orientation.y'\n            [class.resizeable]='plotBand?.resizable'\n            [attr.stroke]=\"plotBand.style?.grabbers?.stroke || 'var(--color-text-50)'\"\n            [attr.stroke-width]='8'\n            [style.transform]=\"axis.orientation === orientation.x ? 'translateX(-2px)' : 'translateY(-2px)'\"\n            [attr.x1]='axis.orientation === orientation.x ? to : 0'\n            [attr.x2]='axis.orientation === orientation.x ? to : width'\n            [attr.data-grabber]=\"'to'\"\n            [attr.y1]='axis.orientation === orientation.x ? 0 : to'\n            [attr.y2]='axis.orientation === orientation.x ? height : to'>\n  </svg:line>\n</ng-container>\n",changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[plot_band_componentngResource_default()]})],PlotBandComponent);var plotline_component_class,plotline_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/plotline/plotline.component.scss?ngResource"),plotline_componentngResource_default=__webpack_require__.n(plotline_componentngResource);let PlotlineComponent=((plotline_component_class=class PlotlineComponent{constructor(cdr,zoomService,scaleService,chartService,element){this.cdr=cdr,this.zoomService=zoomService,this.scaleService=scaleService,this.chartService=chartService,this.element=element,this.orientation=AxisOrientation}ngOnInit(){this._domain=this.scale.domain();const plotlineElement=src.Ys(this.element.nativeElement).select(".plotline"),grabElement=src.Ys(this.element.nativeElement).selectAll(".grabber");this.dragElements=src.ohM().subject((()=>this.axis.orientation===AxisOrientation.y?{y:plotlineElement.attr("y1")}:this.axis.orientation===AxisOrientation.x?{x:plotlineElement.attr("x1")}:void 0));const drag=this.dragElements.on("start drag end",((event,d)=>{d.value=this.scale.invert(event[AxisOrientation[this.axis.orientation]]),null!==d.max&&void 0!==d.max&&d.value>=d.max&&(d.value=d.max),null!==d.min&&void 0!==d.min&&d.value<=d.min&&(d.value=d.min),this.emit({event,target:d}),this.cdr.detectChanges()}));plotlineElement.datum(this.plotLine),grabElement.datum(this.plotLine),this.plotLine.draggable&&grabElement.call(drag)}ngOnDestroy(){this.dragElements.on("start drag end",null)}emit(event){this.chartService.emitPlotline(event)}get value(){return this.scale(this.plotLine.value)}get height(){return this.size.height}get width(){return this.size.width}}).ctorParameters=()=>[{type:core.ChangeDetectorRef},{type:ZoomService},{type:ScaleService},{type:ChartService},{type:core.ElementRef}],plotline_component_class.propDecorators={plotLine:[{type:core.Input}],size:[{type:core.Input}],axis:[{type:core.Input}],scale:[{type:core.Input}]},plotline_component_class);PlotlineComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-plot-line]",template:'<svg:line class="plotline"\n          [attr.stroke]="plotLine.style?.stroke || \'red\'"\n          [attr.stroke-width]="plotLine.style?.strokeWidth || 4"\n          [attr.stroke-dasharray]="plotLine.style?.strokeDasharray"\n          [attr.x1]="axis.orientation === orientation.x ? value : 0"\n          [attr.x2]="axis.orientation === orientation.x ? value : width"\n          [attr.y1]="axis.orientation === orientation.x ? 0 : value"\n          [attr.y2]="axis.orientation === orientation.x ? height : value">\n</svg:line>\n\n\n<svg:text\n  *ngIf="axis.orientation === orientation.x"\n  text-anchor="middle"\n  dominant-baseline="central"\n  class="label font-title-2 fill-text-70"\n  [attr.x]="value"\n  dy="-2em"\n  [attr.transform]="\'rotate(-90, \'+ value +\',\' + height / 2 + \')\'"\n  [attr.y]="height / 2">{{plotLine.label}}\n</svg:text>\n\n<svg:text\n  *ngIf="axis.orientation === orientation.y"\n  text-anchor="middle"\n  class="label font-title-2 fill-text-70"\n  dominant-baseline="central"\n  [attr.x]="value"\n  [attr.y]="width / 2">{{plotLine.label}}\n</svg:text>\n\n<svg:line class="grabber"\n\n          [class.x-grabber]="axis.orientation === orientation.x"\n          [class.y-grabber]="axis.orientation === orientation.y"\n          [attr.stroke]="\'red\'"\n          [attr.stroke-width]="8"\n          opacity="0"\n          [attr.x1]="axis.orientation === orientation.x ? value : 0"\n          [attr.x2]="axis.orientation === orientation.x ? value : width"\n          [attr.y1]="axis.orientation === orientation.x ? 0 : value"\n          [attr.y2]="axis.orientation === orientation.x ? height : value">\n</svg:line>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[plotline_componentngResource_default()]})],PlotlineComponent);var linear_series_base_class,area_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/area-series/area-series.component.scss?ngResource"),area_series_componentngResource_default=__webpack_require__.n(area_series_componentngResource);let LinearSeriesBase=(linear_series_base_class=class LinearSeriesBase extends SeriesBaseComponent{set series(series){this.__series=series,this.markers=this.__series.data?.filter((_=>_?.marker&&void 0!==_?.x&&void 0!==_?.y&&null!==_?.x&&null!==_?.y))}get series(){return this.__series}constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.defaultClipPointsMapping=new Map,this._update=new BehaviorSubject.X(null)}ngOnInit(){this.defaultClipPointsMapping.set(ClipPointsDirection.x,((min,max)=>(point,idx,arr)=>{const bigger=min>max?min:max,smaller=min>max?max:min;return(point.x<=bigger||point.x1<=bigger||arr[idx-1]&&arr[idx-1].x<=bigger||arr[idx-1]&&arr[idx-1].x1<=bigger)&&(point.x>=smaller||point.x1>=smaller||arr[idx+1]&&arr[idx+1].x>=smaller||arr[idx+1]&&arr[idx+1].x1>=smaller)})),this.defaultClipPointsMapping.set(ClipPointsDirection.y,((min,max)=>(point,idx,arr)=>{const bigger=min>max?min:max,smaller=min>max?max:min;return(point.y<=bigger||point.y1<=bigger||arr[idx-1]&&arr[idx-1].y<=bigger||arr[idx-1]&&arr[idx-1].y1<=bigger)&&(point.y>=smaller||point.y1>=smaller||arr[idx+1]&&arr[idx+1].y>=smaller||arr[idx+1]&&arr[idx+1].y1>=smaller)})),this.transform=this.svc.pointerMove.pipe((0,withLatestFrom.M)(this.scaleService.scales),(0,map.U)((data=>{const[event,{x,y}]=data;return this.getTransform(event,x.get(this.series.xAxisIndex).scale,y.get(this.series.yAxisIndex).scale)})),(0,tap.b)((()=>setTimeout((()=>this.cdr.detectChanges()))))),this.path=(0,combineLatest.a)([this.scaleService.scales,this._update]).pipe((0,map.U)((([data])=>{const{x,y}=data;if(this.x=x.get(this.series.xAxisIndex)?.scale,this.y=y.get(this.series.yAxisIndex)?.scale,!this.x||!this.y)return"";const filter=this.defaultClipPointsMapping.get(this.series.clipPointsDirection),line=src.jvg().defined((point=>null!==point.x&&null!==point.y&&void 0!==point.x&&void 0!==point.y&&!isNaN(point.x)&&!isNaN(point.y))).x((point=>this.x(point.x))).y((point=>this.y(point.y)));let filteredData=this.series.data;if(this.series.clipPointsDirection===ClipPointsDirection.x){let[min,max]=this.x.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}if(this.series.clipPointsDirection===ClipPointsDirection.y){let[min,max]=this.y.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}return line(filteredData)})))}ngOnDestroy(){this.svc.setTooltip({point:null,series:this.series})}ngAfterViewInit(){}getTransform(event,scaleX,scaleY){if("mouseleave"===event.type)return null;const mouse=[event?.offsetX,event?.offsetY],tooltipTracking=this.config?.tooltip?.tracking,lineIntersection=(p0_x,p0_y,p1_x,p1_y,p2_x,p2_y,p3_x,p3_y)=>{const rV={};let s1_x,s1_y,s2_x,s2_y,s,t;return s1_x=p1_x-p0_x,s1_y=p1_y-p0_y,s2_x=p3_x-p2_x,s2_y=p3_y-p2_y,s=(-s1_y*(p0_x-p2_x)+s1_x*(p0_y-p2_y))/(-s2_x*s1_y+s1_x*s2_y),t=(s2_x*(p0_y-p2_y)-s2_y*(p0_x-p2_x))/(-s2_x*s1_y+s1_x*s2_y),s>=0&&s<=1&&t>=0&&t<=1&&(rV.x=p0_x+t*s1_x,rV.y=p0_y+t*s1_y),rV};if(tooltipTracking===TooltipTracking.x){const bisect=src.YFb((_=>_.x)).right,pointer=mouse[0];let x0=scaleX.invert(pointer);x0 instanceof Date&&(x0=x0.getTime());const rightId=bisect(this.series.data,x0),intersect=lineIntersection(pointer,scaleY.range()[0],pointer,Number.MAX_SAFE_INTEGER,scaleX(this.series.data[rightId-1]?.x),scaleY(this.series.data[rightId-1]?.y),scaleX(this.series.data[rightId]?.x),scaleY(this.series.data[rightId]?.y)),x=scaleX.invert(intersect.x),y=scaleY.invert(intersect.y);return null==x||isNaN(x)||null==y||isNaN(y)?this.svc.setTooltip({point:null,series:this.series}):this.svc.setTooltip({point:{x:scaleX.invert(intersect.x),y:scaleY.invert(intersect.y)},series:this.series}),{x:intersect.x,y:intersect.y}}if(tooltipTracking===TooltipTracking.y){const bisect=src.YFb((_=>_.y)).right;let y0=scaleY.invert(mouse[1]);y0 instanceof Date&&(y0=y0.getTime());const rightId=bisect(this.series.data,y0),intersect=lineIntersection(scaleX.range()[0],mouse[1],Number.MAX_SAFE_INTEGER,mouse[1],scaleX(this.series.data[rightId-1]?.x),scaleY(this.series.data[rightId-1]?.y),scaleX(this.series.data[rightId]?.x),scaleY(this.series.data[rightId]?.y)),x=scaleX.invert(intersect.x),y=scaleY.invert(intersect.y);return null==x||isNaN(x)||null==y||isNaN(y)?this.svc.setTooltip({point:null,series:this.series}):this.svc.setTooltip({point:{x:scaleX.invert(intersect.x),y:scaleY.invert(intersect.y)},series:this.series}),{x:intersect.x,y:intersect.y}}}},linear_series_base_class.ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],linear_series_base_class.propDecorators={series:[{type:core.Input}]},linear_series_base_class);var area_series_component_class;LinearSeriesBase=(0,tslib_es6.gn)([(0,core.Component)({template:""})],LinearSeriesBase);let AreaSeriesComponent=(area_series_component_class=class AreaSeriesComponent extends LinearSeriesBase{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillDirection=FillDirection,this.fillType=FillType,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){super.ngOnInit(),this.areaPath=this.scaleService.scales.pipe((0,map.U)((data=>{const{x,y}=data;if(this.x=x.get(this.series.xAxisIndex)?.scale,this.y=y.get(this.series.yAxisIndex)?.scale,!this.x||!this.y)return"";const area=src.SOn().defined((point=>null!==point.x&&null!==point.y&&!isNaN(point.x)&&!isNaN(point.y)));area.x1((_=>null!==_.x1&&void 0!==_.x1?this.x(_.x1):this.x(0))).x0((_=>this.x(_.x))).y((_=>this.y(_.y)));const filter=this.defaultClipPointsMapping.get(this.series.clipPointsDirection);let filteredData=this.series.data;if(this.series.clipPointsDirection===ClipPointsDirection.x){let[min,max]=this.x.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}if(this.series.clipPointsDirection===ClipPointsDirection.y){let[min,max]=this.y.domain();min=min instanceof Date?min.getTime():min,max=max instanceof Date?max.getTime():max,filteredData=filteredData?.filter(filter(min,max))}return area(filteredData)})))}},area_series_component_class.ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],area_series_component_class);AreaSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-area-series]",template:'<svg:defs *ngIf="series?.fillType === fillType.gradient">\n  <svg:linearGradient [id]="\'gradient-fill-\' + id" gradientUnits="userSpaceOnUse"\n                      x1="0%"\n                      [attr.y1]="config?.inverted || series?.fillDirection === fillDirection.y ? \'0%\' : \'100%\'"\n                      [attr.x2]="config?.inverted || series?.fillDirection === fillDirection.y ? \'100%\' : \'0%\'"\n                      y2="0%">\n    <svg:stop offset="0%" [attr.stop-color]="series.color" stop-opacity="0"></svg:stop>\n    <svg:stop offset="5%" [attr.stop-color]="series.color" stop-opacity="0.1"></svg:stop>\n    <svg:stop offset="20%" [attr.stop-color]="series.color" stop-opacity="0.2"></svg:stop>\n    <svg:stop offset="60%" [attr.stop-color]="series.color" stop-opacity="0.5"></svg:stop>\n    <svg:stop offset="100%" [attr.stop-color]="series.color" stop-opacity="0.8"></svg:stop>\n  </svg:linearGradient>\n</svg:defs>\n<svg:path\n  class="area"\n  [attr.d]="areaPath | async"\n  [attr.stroke-width]="0"\n  [attr.fill-opacity]="series.style?.fillOpacity"\n  [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : series.style?.fill ?? series.color">\n</svg:path>\n<svg:path\n  class="area"\n  fill="none"\n  [attr.d]="path | async"\n  [attr.stroke]="series.color"\n  [attr.stroke-dasharray]="series.style?.strokeDasharray"\n  [attr.stroke-width]="series.style?.strokeWidth">\n</svg:path>\n<ng-container *ngIf="transform | async as t">\n  <svg:circle\n    *ngIf="t?.x !=null && t?.y !=null"\n    r="3"\n    [attr.fill]="series.color"\n    [attr.transform]="\'translate(\'+ t.x +\', \'+ t.y +\')\'"\n  >\n  </svg:circle>\n</ng-container>\n<ng-container *ngIf="markers as draggablePoints">\n  <svg:circle\n    class="marker"\n    *ngFor="let point of draggablePoints"\n    [class.draggable-marker]="point?.marker?.draggable"\n    [attr.r]="point.marker.style?.radius ?? 5"\n    [attr.fill]="point.marker.style?.fill ?? \'transparent\'"\n    [attr.stroke]="point.marker.style?.stroke ?? \'none\'"\n    [attr.stroke-width]="point.marker.style?.strokeWidth"\n    [attr.stroke-dasharray]="point.marker.style?.strokeDasharray"\n    [attr.cx]="x(point.x)"\n    [attr.cy]="y(point.y)"\n  >\n  </svg:circle>\n</ng-container>\n\n\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[area_series_componentngResource_default()]})],AreaSeriesComponent);var bar_series_component_class,bar_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/bar/bar-series.component.scss?ngResource"),bar_series_componentngResource_default=__webpack_require__.n(bar_series_componentngResource);let BarSeriesComponent=((bar_series_component_class=class BarSeriesComponent extends SeriesBaseComponent{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.Math=Math}ngOnInit(){this.barSeriesCount=this.svc.config.pipe((0,map.U)((_=>_.series.filter((_=>_.type===SeriesType.bar&&_.xAxisIndex===this.series.xAxisIndex)).length))),this.x1=this.scaleService.scales.pipe((0,map.U)((_=>{const x=_.x.get(this.series.xAxisIndex)?.scale,range=x.range(),domain=this.series.data.map((_=>_.x));return src.tiA().range([0,range[1]]).domain(domain).padding(.1)}))),this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.series.yAxisIndex)?.scale)))}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}ngOnChanges(changes){}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],bar_series_component_class);BarSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-bar-series]",template:'<ng-container *ngIf="{\n  x: x | async,\n  x1: x1 | async,\n  y: y | async,\n  barSeriesCount: barSeriesCount | async\n} as data">\n  <ng-container *ngIf="data.x && data.y">\n    <ng-container *ngIf="data.barSeriesCount > 1">\n      <svg:rect\n        *ngFor="let point of series.data"\n        (mouseenter)="mouseenter(point)"\n        (mouseleave)="mouseleave(point)"\n        [attr.x]="data.x(point.x) + (series.id * data.x1.bandwidth() / data.barSeriesCount)"\n        [attr.y]="point.y > 0 ? data.y(point.y) : data.y(0)"\n        [attr.width]="data.x1.bandwidth() / data.barSeriesCount"\n        [attr.height]="Math.abs(data.y(point.y) - data.y(0))"\n        [attr.fill]="series.color"\n      ></svg:rect>\n    </ng-container>\n    <ng-container *ngIf="data.barSeriesCount === 1">\n      <svg:rect\n        *ngFor="let point of series.data"\n        (mouseenter)="mouseenter(point)"\n        (mouseleave)="mouseleave(point)"\n        [attr.x]="data.x(point.x)"\n        [attr.y]="point.y > 0 ? data.y(point.y) : data.y(0)"\n        [attr.width]="data.x1.bandwidth()"\n        [attr.height]="Math.abs(data.y(point.y) - data.y(0))"\n        [attr.fill]="point.color ?? series.color"\n      ></svg:rect>\n    </ng-container>\n  </ng-container>\n</ng-container>\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[bar_series_componentngResource_default()]})],BarSeriesComponent);var block_area_series_component_class,block_area_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/block-area-series/block-area-series.component.scss?ngResource"),block_area_series_componentngResource_default=__webpack_require__.n(block_area_series_componentngResource);let BlockAreaSeriesComponent=((block_area_series_component_class=class BlockAreaSeriesComponent extends SeriesBaseComponent{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillType=FillType,this.Math=Math,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.series.yAxisIndex)?.scale))),this.displayPoints=this.y.pipe((0,filter.h)((y=>y)),(0,map.U)((y=>this.series.data.filter(((point,index,arr)=>{const[min,max]=y.domain();return(point.y>=min||point.y1>=min||arr[index+1]?.y>=min||arr[index+1]?.y1>=min)&&(point.y<=max||point.y1<=max||arr[index-1]?.y<=max||arr[index-1]?.y1<=max)})))))}ngAfterViewInit(){}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],block_area_series_component_class);BlockAreaSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-block-area-series]",template:'<ng-container *ngIf="{\n  y: y | async,\n  x: x | async,\n  points: displayPoints | async\n} as data">\n  <svg:defs *ngIf="series?.fillType === fillType.gradient">\n    <svg:linearGradient [id]="\'gradient-fill-\' + id"\n                        gradientUnits="userSpaceOnUse"\n                        x1="0%"\n                        [attr.y1]="config?.inverted ? \'0%\' : \'100%\'"\n                        [attr.x2]="config?.inverted ? \'100%\' : \'0%\'"\n                        y2="0%">\n      <svg:stop offset="0%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0"></svg:stop>\n      <svg:stop offset="5%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.1"></svg:stop>\n      <svg:stop offset="20%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.2"></svg:stop>\n      <svg:stop offset="60%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.5"></svg:stop>\n      <svg:stop offset="100%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.9"></svg:stop>\n    </svg:linearGradient>\n  </svg:defs>\n  <ng-container *ngIf="data.x && data.y">\n\n\n    <ng-container *ngFor="let point of data.points">\n      <svg:g (mouseenter)="mouseenter(point)"\n             (mouseleave)="mouseleave(point)">\n        <svg:rect\n          *ngIf="!!config.inverted"\n          [attr.x]="data.x(0) < data.x(point.x) ? data.x(0) : data.x(point.x)"\n          [attr.y]="data.y(point.y)"\n          [attr.height]="Math.abs(data.y(point.y1) - data.y(point.y))"\n          [attr.width]="data.x(0) < data.x(point.x) ? data.x(point.x) - data.x(0) : data.x(0) - data.x(point.x)"\n          [attr.stroke]="point.iconId ? \'\' : point.color ?? series.style?.stroke ?? series.color"\n          [attr.stroke-dasharray]="series.style?.strokeDasharray"\n          [attr.stroke-width]="series.style?.strokeWidth"\n          [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.style?.fill ?? series.color"\n          [attr.fill-opacity]="series.style?.fillOpacity">\n        </svg:rect>\n        <svg:rect\n          *ngIf="!config.inverted"\n          [attr.x]="data.x(point.x)"\n          [attr.y]="data.y(0)"\n          [attr.height]="Math.abs(data.y(0) - data.y(point.y))"\n          [attr.width]="data.x(point.x1) - data.x(point.x)"\n          [attr.stroke]="point.iconId ? \'\' : point.color ?? series.color"\n          [attr.stroke-dasharray]="series.style?.strokeDasharray"\n          [attr.stroke-width]="series.style?.strokeWidth"\n          [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.color"\n          [attr.fill-opacity]="series.style?.fillOpacity">\n        </svg:rect>\n        <svg:text *ngIf="point.text"\n                  x="50%"\n                  [attr.y]="(data.y(point.y1) + data.y(point.y)) / 2"\n                  alignment-baseline="middle"\n                  text-anchor="middle">{{ point.text }}\n        </svg:text>\n\n        \x3c!--      <svg:line x1="0" x2="100%" [attr.y1]="data.y(point.y)" [attr.y2]="data.y(point.y)" [attr.stroke]="point.iconId ? \'var(&#45;&#45;color-text-10)\' : point.color ?? series.color"></svg:line>--\x3e\n        \x3c!--      <svg:line x1="0" x2="100%" [attr.y1]="data.y(point.y1)" [attr.y2]="data.y(point.y1)" [attr.stroke]="point.iconId ? \'var(&#45;&#45;color-text-10)\' : point.color ?? series.color"></svg:line>--\x3e\n\n      </svg:g>\n    </ng-container>\n\n  </ng-container>\n</ng-container>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[block_area_series_componentngResource_default()]})],BlockAreaSeriesComponent);var block_horizontal_series_component_class,block_horizontal_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/block-horizontal-series/block-horizontal-series.component.scss?ngResource"),block_horizontal_series_componentngResource_default=__webpack_require__.n(block_horizontal_series_componentngResource);let BlockHorizontalSeriesComponent=((block_horizontal_series_component_class=class BlockHorizontalSeriesComponent extends SeriesBaseComponent{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillType=FillType,this.Math=Math,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.series.yAxisIndex)?.scale))),this.displayPoints=this.x.pipe((0,filter.h)((y=>y)),(0,map.U)((y=>this.series.data.filter(((point,index,arr)=>{const[min,max]=y.domain();return(point.x>=min||point.x1>=min||arr[index+1]?.x>=min||arr[index+1]?.x1>=min)&&(point.x<=max||point.x1<=max||arr[index-1]?.x<=max||arr[index-1]?.x1<=max)})))))}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],block_horizontal_series_component_class);BlockHorizontalSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-block-horizontal-series]",template:'<ng-container *ngIf="{\n  y: y | async,\n  x: x | async,\n  points: displayPoints | async\n} as data">\n  <svg:defs *ngIf="series?.fillType === fillType.gradient">\n    <svg:linearGradient [id]="\'gradient-fill-\' + id" gradientUnits="userSpaceOnUse"\n                        x1="0%"\n                        [attr.y1]="config?.inverted ? \'0%\' : \'100%\'"\n                        [attr.x2]="config?.inverted ? \'100%\' : \'0%\'"\n                        y2="0%">\n      <svg:stop offset="0%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0"></svg:stop>\n      <svg:stop offset="5%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.1"></svg:stop>\n      <svg:stop offset="20%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.2"></svg:stop>\n      <svg:stop offset="60%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.5"></svg:stop>\n      <svg:stop offset="100%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.9"></svg:stop>\n    </svg:linearGradient>\n  </svg:defs>\n  <ng-container *ngIf="data.x && data.y">\n    <ng-container *ngFor="let point of data.points">\n      <svg:g (mouseenter)="mouseenter(point)"\n             (mouseleave)="mouseleave(point)">\n        <svg:rect\n          x="0"\n          [attr.x]="data.x(point.x)"\n          [attr.width]="Math.abs(data.x(point.x1) - data.x(point.x))"\n          [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.style?.fill ?? series.color"\n          [attr.fill-opacity]="series.style?.fillOpacity"\n          height="100%">\n        </svg:rect>\n        <svg:text *ngIf="point.text && data.x(point.x1) - data.x(point.x) > 8"\n                  [attr.transform]="\'rotate(270)\'"\n                  [ngStyle]=\'{"transform-origin": (data.x(point.x1) + data.x(point.x)) / 2+"px 50%"}\'\n                  y="50%"\n                  [attr.x]="(data.x(point.x1) + data.x(point.x)) / 2"\n                  text-anchor="middle" alignment-baseline="middle"\n                  text-anchor="middle">{{ point.text }}\n        </svg:text>\n        <svg:line y1="0" y2="100%" [attr.x1]="data.x(point.x)" [attr.x2]="data.x(point.x)"\n                  [attr.stroke]="point.iconId ? \'var(--color-text-10)\' : point.color ?? series.style?.stroke ?? series.color"></svg:line>\n        <svg:line y1="0" y2="100%" [attr.x1]="data.x(point.x1)" [attr.x2]="data.x(point.x1)"\n                  [attr.stroke]="point.iconId ? \'var(--color-text-10)\' : point.color ?? series.style?.stroke ?? series.color"></svg:line>\n      </svg:g>\n    </ng-container>\n  </ng-container>\n</ng-container>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[block_horizontal_series_componentngResource_default()]})],BlockHorizontalSeriesComponent);var block_series_component_class,block_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/block-series/block-series.component.scss?ngResource"),block_series_componentngResource_default=__webpack_require__.n(block_series_componentngResource);let BlockSeriesComponent=((block_series_component_class=class BlockSeriesComponent extends SeriesBaseComponent{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.fillType=FillType,this.Math=Math,this.id=(Date.now()+Math.random()).toString(36)}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.series.yAxisIndex)?.scale))),this.displayPoints=this.y.pipe((0,filter.h)((y=>y)),(0,map.U)((y=>this.series.data.filter(((point,index,arr)=>{const[min,max]=y.domain();return(point.y>=min||point.y1>=min||arr[index+1]?.y>=min||arr[index+1]?.y1>=min)&&(point.y<=max||point.y1<=max||arr[index-1]?.y<=max||arr[index-1]?.y1<=max)})))))}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],block_series_component_class);BlockSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-block-series]",template:'<ng-container *ngIf="{\n  y: y | async,\n  x: x | async,\n  points: displayPoints | async\n} as data">\n  <svg:defs *ngIf="series?.fillType === fillType.gradient">\n    <svg:linearGradient [id]="\'gradient-fill-\' + id" gradientUnits="userSpaceOnUse"\n                        x1="0%"\n                        [attr.y1]="config?.inverted ? \'0%\' : \'100%\'"\n                        [attr.x2]="config?.inverted ? \'100%\' : \'0%\'"\n                        y2="0%">\n      <svg:stop offset="0%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0"></svg:stop>\n      <svg:stop offset="5%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.1"></svg:stop>\n      <svg:stop offset="20%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.2"></svg:stop>\n      <svg:stop offset="60%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.5"></svg:stop>\n      <svg:stop offset="100%" [attr.stop-color]="series.style?.fill ?? series.color" stop-opacity="0.9"></svg:stop>\n    </svg:linearGradient>\n  </svg:defs>\n  <ng-container *ngIf="data.x && data.y">\n    <ng-container *ngFor="let point of data.points">\n      <svg:g (mouseenter)="mouseenter(point)"\n             (mouseleave)="mouseleave(point)">\n        <svg:rect\n          x="0"\n          [attr.y]="data.y(point.y)"\n          [attr.height]="Math.abs(data.y(point.y1) - data.y(point.y))"\n          [attr.fill]="series.fillType === fillType.gradient ? \'url(#gradient-fill-\'+id+\')\' : point.iconId ? \'url(#pattern\'+point.iconId+\')\' : point.color ?? series.style?.fill ?? series.color"\n          [attr.fill-opacity]="series.style?.fillOpacity"\n          width="100%">\n        </svg:rect>\n        <svg:text *ngIf="point.text && data.y(point.y1) - data.y(point.y) > 8"\n                  x="50%"\n                  [attr.y]="(data.y(point.y1) + data.y(point.y)) / 2"\n                  alignment-baseline="middle"\n                  text-anchor="middle">{{ point.text }}\n        </svg:text>\n        <svg:line x1="0" x2="100%" [attr.y1]="data.y(point.y)" [attr.y2]="data.y(point.y)"\n                  [attr.stroke]="point.iconId ? \'var(--color-text-10)\' : point.color ?? series.style?.stroke ?? series.color"></svg:line>\n        <svg:line x1="0" x2="100%" [attr.y1]="data.y(point.y1)" [attr.y2]="data.y(point.y1)"\n                  [attr.stroke]="point.iconId ? \'var(--color-text-10)\' : point.color ?? series.style?.stroke ?? series.color"></svg:line>\n      </svg:g>\n    </ng-container>\n\n  </ng-container>\n</ng-container>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[block_series_componentngResource_default()]})],BlockSeriesComponent);var line_series_component_class,line_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/line/line-series.component.scss?ngResource"),line_series_componentngResource_default=__webpack_require__.n(line_series_componentngResource);let LineSeriesComponent=((line_series_component_class=class LineSeriesComponent extends LinearSeriesBase{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element,this.allowDrag=point=>newPoint=>!(null!==point.marker.minX&&void 0!==point.marker.minX&&this.x.invert(this.x(this.start.x)+newPoint.deltaX)<point.marker.minX)&&(!(null!==point.marker.maxX&&void 0!==point.marker.maxX&&this.x.invert(this.x(this.start.x)+newPoint.deltaX)>point.marker.maxX)&&(!(null!==point.marker.minY&&void 0!==point.marker.minY&&this.y.invert(this.y(this.start.y)+newPoint.deltaY)<point.marker.minY)&&!(null!==point.marker.maxY&&void 0!==point.marker.maxY&&this.y.invert(this.y(this.start.y)+newPoint.deltaY)>point.marker.maxY)))}moveStart(event,point){this.start={x:point.x,y:point.y}}moveEnd(event,point){point.x=this.x.invert(this.x(this.start.x)+event.deltaX),point.y=this.y.invert(this.y(this.start.y)+event.deltaY),this._update.next();const emitEvent={type:"end",sourceEvent:event};this.svc.emitPoint({target:{series:this.series,point},event:emitEvent})}moveProcess(event,point){point.x=this.x.invert(this.x(this.start.x)+event.deltaX),point.y=this.y.invert(this.y(this.start.y)+event.deltaY),this._update.next();const emitEvent={type:"drag",sourceEvent:event};this.svc.emitPoint({target:{series:this.series,point},event:emitEvent})}startLabel(event,label){this.labelStart={dx:label.dx,dy:label.dy}}moveLabel(event,label){label.dx=this.labelStart.dx+event.deltaX,label.dy=this.labelStart.dy+event.deltaY}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],line_series_component_class);LineSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-line-series]",template:'<svg:path\n  class="line"\n  [attr.d]="path | async"\n  [attr.stroke]="series.color"\n  [attr.stroke-dasharray]="series.style?.strokeDasharray"\n  [attr.stroke-width]="series.style?.strokeWidth"\n  fill="none">\n</svg:path>\n<ng-container *ngIf="transform | async as t">\n  <svg:circle\n    *ngIf="t?.x !=null && t?.y!=null"\n    r="3"\n    [attr.fill]="series.color"\n    [attr.transform]="\'translate(\'+ t.x +\', \'+ t.y +\')\'"\n  >\n  </svg:circle>\n</ng-container>\n<ng-container *ngIf="markers as draggablePoints">\n  <ng-container *ngIf="x && y">\n    <svg:g\n      *ngFor="let point of draggablePoints"\n      [attr.transform]="\'translate(\' + x(point.x) + \',\' + y(point.y) + \')\'">\n      <svg:g [tetaDraggablePoint]="point.marker.draggable"\n             [dragDirection]="point.marker.dragType"\n             [allowDrag]="allowDrag(point)"\n             #dragPoint="tetaDraggablePoint"\n             (moveStart)="moveStart($event, point)"\n             (moveEnd)="moveEnd($event, point);dragPoint.resetTransform();"\n             (moveProcess)="moveProcess($event, point);dragPoint.resetTransform();"\n             [class.draggable-marker]="point?.marker?.draggable">\n        <svg:circle\n          class="marker"\n          [attr.r]="point.marker.style?.radius ?? 5"\n          [attr.fill]="point.marker.style?.fill ?? \'transparent\'"\n          [attr.stroke]="point.marker.style?.stroke ?? \'none\'"\n          [attr.stroke-width]="point.marker.style?.strokeWidth"\n          [attr.stroke-dasharray]="point.marker.style?.strokeDasharray"\n          [attr.cx]="0"\n          [attr.cy]="0">\n        </svg:circle>\n        <ng-container *ngIf="point.marker.label?.text">\n          <svg:line\n            [attr.x1]="0"\n            [attr.y1]="0"\n            [attr.x2]="point.marker.label?.dx"\n            [attr.y2]="point.marker.label?.dy"\n            [attr.stroke]="point.marker.label?.style?.stroke ?? \'var(--color-text-90)\'"\n            [attr.stroke-width]="point.marker.label?.style?.strokeWidth ?? 1"\n            [attr.stroke-dasharray]="point.marker.label?.style?.strokeDasharray ?? null">\n          </svg:line>\n          <svg:foreignObject\n            [tetaDraggablePoint]="point.marker.label?.draggable"\n            [dragDirection]="point.marker.label.dragType"\n            #labelPoint="tetaDraggablePoint"\n            (moveStart)="startLabel($event, point.marker.label)"\n            (moveProcess)="moveLabel($event, point.marker.label); labelPoint.resetTransform();"\n            (moveEnd)="labelPoint.resetTransform();"\n            [attr.width]="annotationNode?.offsetWidth ?? 0"\n            [attr.height]="annotationNode?.offsetHeight ?? 0"\n            [attr.x]="point.marker.label?.dx"\n            [attr.y]="point.marker.label?.dy"\n            class="position-absolute">\n            <div\n              #annotationNode\n              class="shadow-2 padding-2"\n              [style.color]="\'var(--color-text-90)\'"\n              [style.background-color]="\'var(--color-global-bgcard)\'"\n              [style.cursor]="\'move\'"\n              style="border-radius: 2px; display: inline-block;">\n              {{point.marker.label?.text}}\n            </div>\n          </svg:foreignObject>\n        </ng-container>\n      </svg:g>\n    </svg:g>\n  </ng-container>\n\n</ng-container>\n\n\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[line_series_componentngResource_default()]})],LineSeriesComponent);var scatter_series_component_class,scatter_series_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/series/scatter-series/scatter-series.component.scss?ngResource"),scatter_series_componentngResource_default=__webpack_require__.n(scatter_series_componentngResource);let ScatterSeriesComponent=((scatter_series_component_class=class ScatterSeriesComponent extends SeriesBaseComponent{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.series.yAxisIndex)?.scale)))}ngAfterViewInit(){}mouseenter(point){this.svc.setTooltip({point,series:this.series})}mouseleave(point){this.svc.setTooltip({point:null,series:this.series})}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],scatter_series_component_class);ScatterSeriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-scatter-series]",template:'<ng-container *ngIf="{\n  y: y | async,\n  x: x | async\n} as scales">\n  <ng-container *ngIf="scales.x && scales.y">\n    <svg:circle\n      class="line"\n      *ngFor="let point of series.data"\n      (mouseenter)="mouseenter(point)"\n      (mouseleave)="mouseleave(point)"\n      [attr.cx]="scales.x(point.x)"\n      [attr.cy]="scales.y(point.y)"\n      [attr.r]="series.style?.radius ?? 1"\n      [attr.stroke]="point.color ?? series.color"\n      [attr.fill]="point.color ?? series.color"\n      [attr.stroke-width]="series.style?.strokeWidth">\n    </svg:circle>\n  </ng-container>\n</ng-container>\n\n\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[scatter_series_componentngResource_default()]})],ScatterSeriesComponent);const defaultSeriesTypeMapping=(new Map).set(SeriesType.line,LineSeriesComponent).set(SeriesType.bar,BarSeriesComponent).set(SeriesType.scatter,ScatterSeriesComponent).set(SeriesType.block,BlockSeriesComponent).set(SeriesType.area,AreaSeriesComponent).set(SeriesType.blockArea,BlockAreaSeriesComponent);var series_host_component_class;let SeriesHostComponent=((series_host_component_class=class SeriesHostComponent{constructor(viewContainerRef){this.viewContainerRef=viewContainerRef,this._init=!1}ngOnInit(){SeriesBaseComponent.isPrototypeOf(this.series.component)||(this.series.component=defaultSeriesTypeMapping.get(this.series.type)||LineSeriesComponent),this._componentRef=this.viewContainerRef.createComponent(this.series.component),this._componentRef.instance.config=this.config,this._componentRef.instance.series=this.series,this._init=!0}ngOnDestroy(){this._componentRef.destroy()}ngOnChanges(changes){this._init&&(changes.hasOwnProperty("series")||changes.hasOwnProperty("config"))&&(this._componentRef.instance.config=this.config,this._componentRef.instance.series=this.series,this._componentRef.injector.get(core.ChangeDetectorRef).detectChanges())}}).ctorParameters=()=>[{type:core.ViewContainerRef}],series_host_component_class.propDecorators={config:[{type:core.Input}],series:[{type:core.Input}]},series_host_component_class);SeriesHostComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-series-host]",template:"",changeDetection:core.ChangeDetectionStrategy.OnPush})],SeriesHostComponent);var tooltip_component_class,tooltip_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/tooltip/tooltip.component.scss?ngResource"),tooltip_componentngResource_default=__webpack_require__.n(tooltip_componentngResource),platform_browser=__webpack_require__("./node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs");let TooltipComponent=((tooltip_component_class=class TooltipComponent{constructor(svc,cdr,zoomService,sanitizer,_zone,_elementRef){this.svc=svc,this.cdr=cdr,this.zoomService=zoomService,this.sanitizer=sanitizer,this._zone=_zone,this._elementRef=_elementRef,this.tooltips=this.svc.tooltips.pipe((0,map.U)((_=>[..._.values()])))}ngOnInit(){this.display=this.svc.pointerMove.pipe((0,map.U)((event=>"mousemove"===event.type?1:0)),(0,tap.b)((()=>{setTimeout((()=>{this.cdr.detectChanges()}))}))),this.position=this.svc.pointerMove.pipe((0,filter.h)((event=>!!event)),(0,map.U)((_=>this.getPosition(_))),(0,tap.b)((()=>this.cdr.detectChanges())));const transformHtml=html=>this.sanitizer.bypassSecurityTrustHtml(html),formatter=this.config?.tooltip?.format;this.displayTooltips=this.svc.tooltips.pipe((0,map.U)((tooltips=>{const tooltipList=[...tooltips.values()];if(tooltipList?.length<1)return"";const formatted=formatter?transformHtml(formatter(tooltipList)):(tooltips=>{let html="";const format=src.i$Z("%d.%m.%Y");return tooltips.forEach((_=>{html+=`<div class='display-flex align-center'><span class='margin-right-1' style='display:block; width: 10px; height: 2px; background-color: ${_?.series?.color}'></span>\n          <span class='font-title-3'>${_.series.name}\n            <span class='font-body-3'>\n              x: ${_.point.x instanceof Date?format(_.point.x):_.point.x?.toFixed(2)}\n              y: ${_.point.y instanceof Date?format(_.point.y):_.point.y?.toFixed(2)}\n            </span>\n          </span></div>`})),transformHtml(html)})(tooltipList);return formatted})))}getPosition(event){return this.tooltip?tetacom_ng_components.TUH.getPosition({top:event.pageY,bottom:event.pageY,left:event.pageX,right:event.pageX},this.tooltip?.nativeElement?.getBoundingClientRect(),tetacom_ng_components.xMy.auto,tetacom_ng_components.g$I.top,12):null}format(input){if(input instanceof Date){return src.i$Z("%d.%m.%Y")(input)}return src.WUZ(",.5~r")(input)}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ZoomService},{type:platform_browser.DomSanitizer},{type:core.NgZone},{type:core.ElementRef}],tooltip_component_class.propDecorators={size:[{type:core.Input}],config:[{type:core.Input}],tooltip:[{type:core.ViewChild,args:["tooltip",{static:!1,read:core.ElementRef}]}]},tooltip_component_class);TooltipComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"teta-tooltip",template:'<ng-container *tetaLet="position | async as p">\n  <ng-container *ngIf="tooltips | async as t">\n    <div class="chart-tooltip color-text-90 bg-global-bgcard shadow-2"\n         #tooltip\n         [style.position]="\'fixed\'"\n         *ngIf="t.length > 0"\n         [style.opacity]="display | async"\n         [hidden]="!p"\n         style="pointer-events: none; min-width: 200px;"\n         [style.left.px]="p?.left"\n         [style.top.px]="p?.top"\n         [style.bottom.px]="p?.bottom"\n         [style.right.px]="p?.right"\n    >\n      <ng-container *ngIf="config.tooltip?.template">\n        <ng-container *ngTemplateOutlet="config.tooltip.template; context: {$implicit: t}"></ng-container>\n      </ng-container>\n\n      <ng-container *ngIf="config.tooltip?.format; else default">\n        <div [innerHTML]="displayTooltips | async"></div>\n      </ng-container>\n\n      <ng-template #default>\n        <div *ngIf="!config.tooltip?.template" class="padding-2 border-radius-1">\n          <ng-container *ngFor="let tooltip of t">\n            <div class="display-flex align-center">\n            <span class="display-block margin-right-1" [style.width.px]="10" [style.height.px]="2"\n                  [style.background-color]="tooltip.series?.color"></span>\n              <span class="font-title-3">\n            {{ tooltip.series?.name }}\n                <span class="font-body-3">\n              x: {{ format(tooltip.point?.x) }}\n                  y: {{ format(tooltip.point?.y) }}\n            </span>\n          </span>\n            </div>\n          </ng-container>\n        </div>\n      </ng-template>\n    </div>\n  </ng-container>\n</ng-container>\n\n\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[tooltip_componentngResource_default()]})],TooltipComponent);var x_axis_component_class,x_axis_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/x-axis/x-axis.component.scss?ngResource"),x_axis_componentngResource_default=__webpack_require__.n(x_axis_componentngResource);let XAxisComponent=((x_axis_component_class=class XAxisComponent{constructor(scaleService,_svc){this.scaleService=scaleService,this._svc=_svc,this.update$=new BehaviorSubject.X(null),this._alive=!0,this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.axis.index)?.scale))),this.ticks=(0,combineLatest.a)([this.x,this.update$]).pipe((0,withLatestFrom.M)(this._svc.size),(0,map.U)((_=>{const[[x],size]=_,tickSize=x.ticks().map((_=>getTextWidth(this.axis.options.tickFormat?this.axis.options.tickFormat(_):this.axis.defaultFormatter()(_),.45,11)));return x.ticks(size.width/parseInt(src.Fp7(tickSize),10)/5)})))}getLabelTransform(){return`translate(${this.size.width/2}, ${this.axis.options.opposite?-32:32})`}ngOnInit(){}ngOnDestroy(){this._alive=!1}ngOnChanges(changes){changes.hasOwnProperty("axis")&&this.update$.next()}}).ctorParameters=()=>[{type:ScaleService},{type:ChartService}],x_axis_component_class.propDecorators={axis:[{type:core.Input}],size:[{type:core.Input}]},x_axis_component_class);XAxisComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-x-axis]",template:'<ng-container *ngIf="{x: x | async, ticks: ticks | async} as data">\n  <svg:g text-anchor="middle" *ngFor="let tick of data.ticks" [attr.transform]="\'translate(\'+ data.x(tick) +\', 0)\'">\n    <text fill="var(--color-text-70)" [attr.dy]="axis.options.opposite ? \'-0.71em\' : \'0.71em\'" [attr.y]="axis.options.opposite ? 0 : 9">{{ this.axis.options.tickFormat ? this.axis.options.tickFormat(tick) : this.axis.defaultFormatter()(tick) }}</text>\n    <line stroke="var(--color-text-30)" [attr.y2]="axis.options.opposite ? -6 : 6"></line>\n  </svg:g>\n\n  <svg:g class="label-axis font-caption" [attr.transform]="getLabelTransform()">\n    <text fill="var(--color-text-70)"  text-anchor="middle" dominant-baseline="middle">{{ axis.options.title }}</text>\n  </svg:g>\n</ng-container>\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[x_axis_componentngResource_default()]})],XAxisComponent);var y_axis_component_class,y_axis_componentngResource=__webpack_require__("./projects/chart/src/chart/chart-container/y-axis/y-axis.component.scss?ngResource"),y_axis_componentngResource_default=__webpack_require__.n(y_axis_componentngResource);let YAxisComponent=((y_axis_component_class=class YAxisComponent{constructor(scaleService){this.scaleService=scaleService,this._alive=!0,this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.axis.index)?.scale)))}ngOnInit(){}ngOnDestroy(){this._alive=!1}ngAfterViewInit(){}getLabelTransform(){return`translate(${this.axis.options.opposite?this.axis.selfSize:-this.axis.selfSize}, ${this.size.height/2}) rotate(-90)`}}).ctorParameters=()=>[{type:ScaleService}],y_axis_component_class.propDecorators={axis:[{type:core.Input}],size:[{type:core.Input}]},y_axis_component_class);var brushable_directive_class;YAxisComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"[teta-y-axis]",template:'<ng-container *ngIf="y | async as scale">\n  <svg:g [attr.text-anchor]="axis.options.opposite ? \'start\' : \'end\'" *ngFor="let tick of scale.ticks()" [attr.transform]="\'translate(0, \'+ scale(tick) +\')\'">\n    <text fill="var(--color-text-70)" dy="0.32em" [attr.x]="axis.options.opposite ? 10 : -9">{{ this.axis.options.tickFormat ? this.axis.options.tickFormat(tick) : this.axis.defaultFormatter()(tick) }}</text>\n    <line stroke="var(--color-text-30)" [attr.x2]="axis.options.opposite ? 6 : -6"></line>\n  </svg:g>\n\n  <svg:g class="label-axis font-caption" [attr.transform]="getLabelTransform()">\n    <text [attr.dy]="axis.options.opposite ? \'-4px\' : \'4px\'" text-anchor="middle" [attr.dominant-baseline]="axis.options.opposite ? \'auto\' : \'hanging\'">{{ axis.options.title }}</text>\n  </svg:g>\n</ng-container>\n\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[y_axis_componentngResource_default()]})],YAxisComponent);let BrushableDirective=((brushable_directive_class=class BrushableDirective{constructor(brushService,chartService,element,zone){this.brushService=brushService,this.chartService=chartService,this.element=element,this.zone=zone,this.brushMap=(new Map).set(BrushType.x,src.Yud()).set(BrushType.y,src.Lae()),this._alive=!0,this._container=src.Ys(this.element.nativeElement)}ngOnInit(){this.brushService.brushDomain.pipe((0,takeWhile.o)((()=>this._alive)),(0,filter.h)((brush=>brush.chartId!==this.config.id))).subscribe((brush=>{this._container.call(this.brush.move,[Math.floor(brush.selection[0]),Math.floor(brush.selection[1])].map(this.axis.scale))}))}ngOnDestroy(){this._alive=!1}ngAfterViewInit(){if(this.config?.brush?.enable){const brushMessage=new BrushMessage({chartId:this.config.id,selection:[this.config?.brush?.from,this.config?.brush?.to],mode:"init"});this.brushService.setBrush(brushMessage)}}ngOnChanges(changes){changes.hasOwnProperty("config")&&this.clearPreviousSelection(),this.config?.brush?.enable&&this.applyBrush(this.config,this.axis.scale)}applyBrush(config,brushScale){this.brush?.on("start brush end",null),config.brush?.enable&&(this.brush=this.brushMap.get(config?.brush?.type??BrushType.x),this.brush.on("start brush end",(_=>{if(_.sourceEvent){if(!_.selection)return;const[from,to]=_.selection;if(to-from==0){const selection=this.selection?.map(brushScale)??[config.brush?.from,config.brush?.to].map(brushScale),halfBrushHeight=(selection[1]-selection[0])/2,invertedSelection=[from-halfBrushHeight,to+halfBrushHeight].map(brushScale.invert);return invertedSelection[1]-invertedSelection[0]>config.brush?.max?void this._container.call(this.brush.move,[Math.floor(invertedSelection[0]),Math.floor(invertedSelection[0]+config.brush?.max)].map(brushScale)):invertedSelection[1]-invertedSelection[0]<config.brush?.min?void this._container.call(this.brush.move,[Math.floor(invertedSelection[0]),Math.ceil(invertedSelection[0]+config.brush?.min)].map(brushScale)):void this._container.call(this.brush.move,[from-halfBrushHeight,to+halfBrushHeight])}if(brushScale.invert(to)-brushScale.invert(from)>config.brush?.max)return void this._container.call(this.brush.move,this.selection?[this.selection[0],this.selection[0]+config.brush?.max].map(brushScale):[config.brush?.from,config.brush?.to].map(brushScale));if(brushScale.invert(to)-brushScale.invert(from)<config.brush?.min)return void this._container.call(this.brush.move,this.selection?[this.selection[0],this.selection[0]+config.brush?.min].map(brushScale):[config.brush?.from,config.brush?.to].map(brushScale));_.sourceEvent instanceof MouseEvent&&(this.selection=_.selection.map(brushScale.invert));const brushMessage=new BrushMessage({chartId:this.config.id,selection:[brushScale.invert(from),brushScale.invert(to)],mode:_.mode});this.brushService.setBrush(brushMessage)}})),this.zone.runOutsideAngular((()=>{setTimeout((()=>{this._container.call(this.brush);let domain=brushScale.domain();config?.brush?.from&&(domain[0]=config.brush.from),config?.brush?.to&&(domain[1]=config.brush.to),this._container.call(this.brush.move,this.selection?this.selection.map(brushScale):domain.map(brushScale),{})}),0)})))}clearPreviousSelection(){this.selection=null}}).ctorParameters=()=>[{type:BrushService},{type:ChartService},{type:core.ElementRef},{type:core.NgZone}],brushable_directive_class.propDecorators={config:[{type:core.Input}],axis:[{type:core.Input}]},brushable_directive_class);var DragPointType,draggable_point_directive_class;BrushableDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[tetaBrushable]"})],BrushableDirective),function(DragPointType){DragPointType[DragPointType.x=0]="x",DragPointType[DragPointType.y=1]="y",DragPointType[DragPointType.xy=2]="xy"}(DragPointType||(DragPointType={}));let DraggablePointDirective=((draggable_point_directive_class=class DraggablePointDirective{constructor(_elementRef){this._elementRef=_elementRef,this.moveStart=new core.EventEmitter,this.moveProcess=new core.EventEmitter,this.moveEnd=new core.EventEmitter}mouseDown(event){this.tetaDraggablePoint&&(event.stopPropagation(),event.preventDefault(),this.startPosition={x:event.x,y:event.y},this.moveStart.emit(this.startPosition))}mouseUp(event){if(null!==this.startPosition&&void 0!==this.startPosition){let deltaX=event.x-this.startPosition.x,deltaY=event.y-this.startPosition.y;if(this.dragDirection===DragPointType.x&&(deltaY=0),this.dragDirection===DragPointType.y&&(deltaX=0),this.allowDrag&&!this.allowDrag({x:event.x,y:event.y,deltaX,deltaY}))return void(this.startPosition=null);this.transformCache?(this.transformCache.x=this.transformCache.x+deltaX,this.transformCache.y=this.transformCache.y+deltaY):this.transformCache={x:deltaX,y:deltaY},this.moveEnd.emit({x:event.x,y:event.y,deltaX,deltaY})}this.startPosition=null}mouseMove(event){if(this.startPosition){let deltaX=event.x-this.startPosition.x,deltaY=event.y-this.startPosition.y;if(this.transformCache&&(deltaX=this.transformCache.x+deltaX,deltaY=this.transformCache.y+deltaY),this.allowDrag&&!this.allowDrag({x:event.x,y:event.y,deltaX,deltaY}))return;this.dragDirection===DragPointType.x&&(deltaY=0),this.dragDirection===DragPointType.y&&(deltaX=0),this.setTransform(deltaX,deltaY),event.stopPropagation(),event.preventDefault(),this.moveProcess.emit({x:event.x,y:event.y,deltaX,deltaY})}}setTransform(x,y){this._elementRef.nativeElement.style.transform=`translate(${x}px, ${y}px)`}resetTransform(){this.setTransform(0,0),this.transformCache=null}}).ctorParameters=()=>[{type:core.ElementRef}],draggable_point_directive_class.propDecorators={tetaDraggablePoint:[{type:core.Input}],dragDirection:[{type:core.Input}],allowDrag:[{type:core.Input}],moveStart:[{type:core.Output}],moveProcess:[{type:core.Output}],moveEnd:[{type:core.Output}],mouseDown:[{type:core.HostListener,args:["mousedown",["$event"]]},{type:core.HostListener,args:["touchstart",["$event"]]}],mouseUp:[{type:core.HostListener,args:["window:mouseup",["$event"]]},{type:core.HostListener,args:["window:touchend",["$event"]]}],mouseMove:[{type:core.HostListener,args:["window:mousemove",["$event"]]},{type:core.HostListener,args:["window:touchmove",["$event"]]}]},draggable_point_directive_class);var zoomable_directive_class;DraggablePointDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[tetaDraggablePoint]",exportAs:"tetaDraggablePoint"})],DraggablePointDirective);let ZoomableDirective=((zoomable_directive_class=class ZoomableDirective{mouseenter(){this.zoom?.on("start zoom end",this.zoomed),this._element?.call(this.zoom).on("dblclick.zoom",null),this.config?.zoom?.zoomBehavior===ZoomBehaviorType.wheel&&this.runWheelTranslate()}mouseleave(){this.zoom?.on("start zoom end",null),this._element?.on("wheel",null)}constructor(elementRef,zoomService,chartService,zone){this.elementRef=elementRef,this.zoomService=zoomService,this.chartService=chartService,this.zone=zone,this.zoomable=!1,this.crosshair=!1,this.alive=!0,this.currentTransform=src.CRH,this.zoomed=event=>{if(event.sourceEvent&&(this.elementRef.nativeElement===event.sourceEvent.target||this.elementRef.nativeElement.contains(event.sourceEvent.target))){if(0!==Object.keys(event.sourceEvent).length){const origin=this.axis.scale.copy().domain(this.axis.originDomain);if(this.axis.options.scaleType.type===ScaleType.band)return;const domain=this.axis.orientation===AxisOrientation.y?event.transform.rescaleY(origin).domain():event.transform.rescaleX(origin).domain();if(null===domain[0]||void 0===domain[0]||null===domain[1]||void 0===domain[1]||Math.abs(domain[0]-domain[1])<1e-6)return;const message=new ZoomMessage({eventType:event.type,axis:{index:this.axis.index,orientation:this.axis.orientation},element:this.elementRef,domain,chartId:this.config.id});this.zoomService.fireZoom(message),this.zoomService.broadcastZoom(message)}this.currentTransform=event.transform}}}ngOnInit(){(this.axis?.options?.zoom||this.config?.zoom?.enable)&&(this.zoomable=this.config?.zoom?.zoomBehavior===ZoomBehaviorType.move&&!this.config?.tooltip?.showCrosshair,this.crosshair=this.config?.tooltip?.showCrosshair)}ngAfterViewInit(){this.initZoomListeners(),this.initZoomSync()}ngOnDestroy(){this.zoom?.on("start zoom end",null),this._element?.on("wheel",null),this.alive=!1}initZoomSync(){this.zoomService.zoomed.pipe((0,takeWhile.o)((()=>this.alive))).subscribe((zoomed=>{if(this._element&&this.elementRef!==zoomed?.element&&zoomed?.axis?.index===this.axis.index&&zoomed?.axis?.orientation===this.axis.orientation){const scale=this.axis.scale.copy().domain(this.axis.originDomain);let transform;transform=null===zoomed.domain?src.CRH:this.zoomService.getD3Transform(zoomed.domain,this.axis.originDomain,scale,this.axis.orientation,this.axis.options.inverted),this._element.call(this.zoom.transform,transform),this.currentTransform=transform}}))}initZoomListeners(){if(!(this.axis?.options?.zoom&&!1!==this.axis?.options.visible||this.config?.zoom?.enable))return;this._element=src.Ys(this.elementRef.nativeElement),this.zoom=src.sPX().extent([[0,0],[this.size.width,this.size.height]]);const min=null!=this.config?.zoom?.minTranslate?this.axis.scale(this.config?.zoom?.minTranslate):-1/0,max=null!=this.config?.zoom?.maxTranslate?this.axis.scale(this.config?.zoom?.maxTranslate):1/0;if(this.axis.orientation===AxisOrientation.x&&this.config.zoom.type===ZoomType.x&&this.zoom.translateExtent([[Math.min(min,max),-1/0],[Math.max(min,max),1/0]]),this.axis.orientation===AxisOrientation.y&&this.config.zoom.type===ZoomType.y&&this.zoom.translateExtent([[-1/0,Math.min(min,max)],[1/0,Math.max(min,max)]]),this.config.zoom?.wheelDelta&&this.zoom.wheelDelta(this.config.zoom?.wheelDelta),this.config?.zoom?.wheelFilter&&this.zoom.filter(this.config?.zoom?.wheelFilter),this.axis.options.scaleType.type!==ScaleType.band){const extremes=this.axis.extremes,maxZoom=this.config.zoom?.max?(extremes[1]-extremes[0])/this.config.zoom?.max:this.config.zoom?.limitZoomByData?1:0,minZoom=this.config.zoom?.min?(extremes[1]-extremes[0])/this.config.zoom?.min:1/0;this.zoom.scaleExtent([maxZoom,minZoom])}this.config?.zoom?.zoomBehavior===ZoomBehaviorType.wheel&&this.runWheelTranslate()}runWheelTranslate(){let wheeling,type="start";this.zoom.on("start zoom end",this.zoomed),this._element?.call(this.zoom),this.zoom.filter((event=>event.ctrlKey&&"wheel"===event.type||Boolean(window.TouchEvent&&"wheel"!==event.type))).wheelDelta((event=>.002*(this.config?.zoom.type===ZoomType.x?-event.deltaX:-event.deltaY)));const emit=(type,event)=>{const origin=this.axis.scale.copy().domain(this.axis.originDomain);let transform=src.CRH;const delta="end"===type?0:this.axis.orientation===AxisOrientation.y?event.deltaY:event.deltaX;this.axis.orientation===AxisOrientation.y&&(transform=transform.translate(0,this.currentTransform.y-delta/2)),this.axis.orientation===AxisOrientation.x&&(transform=transform.translate(this.currentTransform.x-delta/2,0)),transform=transform.scale(this.currentTransform.k);let domain=this.axis.orientation===AxisOrientation.y?transform.rescaleY(origin).domain():transform.rescaleX(origin).domain();const extent=this.axis.options?.inverted?domain:[...domain].reverse();if(extent[0]<=this.config.zoom?.minTranslate)return;if(extent[1]>=this.config.zoom?.maxTranslate)return;const message=new ZoomMessage({eventType:type,element:this.elementRef,axis:{index:this.axis.index,orientation:this.axis.orientation},domain,chartId:this.config.id});this._element?.call(this.zoom.transform,transform),this.zoomService.fireZoom(message),this.zoomService.broadcastZoom(message),this.currentTransform=transform};this._element.on("wheel",(event=>{event.preventDefault(),event.ctrlKey||this.zone.runOutsideAngular((()=>{clearTimeout(wheeling),emit(type,event),type="zoom",wheeling=setTimeout((()=>{emit("end",event),type="start"}),50)}))}))}}).ctorParameters=()=>[{type:core.ElementRef},{type:ZoomService},{type:ChartService},{type:core.NgZone}],zoomable_directive_class.propDecorators={config:[{type:core.Input}],axis:[{type:core.Input}],size:[{type:core.Input}],zoomable:[{type:core.HostBinding,args:["class.zoomable"]}],crosshair:[{type:core.HostBinding,args:["class.crosshair"]}],mouseenter:[{type:core.HostListener,args:["mouseenter"]}],mouseleave:[{type:core.HostListener,args:["mouseleave"]}]},zoomable_directive_class);ZoomableDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[tetaZoomable]"})],ZoomableDirective);var legend_component_class,legend_componentngResource=__webpack_require__("./projects/chart/src/chart/legend/legend.component.scss?ngResource"),legend_componentngResource_default=__webpack_require__.n(legend_componentngResource);let LegendComponent=((legend_component_class=class LegendComponent{constructor(chartService){this.chartService=chartService,this.sizeMapping=(new Map).set(SeriesType.line,2).set(SeriesType.scatter,2).set(SeriesType.bar,12).set(SeriesType.area,2).set(SeriesType.block,12).set(SeriesType.blockArea,2),this.classLegend=!0}getHeight(serie){return this.sizeMapping.get(serie.type??SeriesType.line)}click(serie){this.chartService.toggleVisibilitySeries([serie.id])}}).ctorParameters=()=>[{type:ChartService}],legend_component_class.propDecorators={series:[{type:core.Input}],classLegend:[{type:core.HostBinding,args:["class.padding-bottom-4"]}]},legend_component_class);LegendComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"teta-legend",template:'<ng-container *ngFor="let serie of series" class="padding-bottom-4">\n  <div *ngIf="serie?.showInLegend !== false">\n    <div class="legend-item cursor-pointer" (click)="click(serie)">\n      <div class="legend-icon-form"\n           [style.height.px]="getHeight(serie)"\n           [style.border-top-color]="serie.visible ? serie.color : \'var(--color-text-30)\'"\n           [style.border-top-style]="serie.style?.strokeDasharray ? \'dashed\' : \'solid\'"\n           [style.border-width.px]="serie.style?.strokeDasharray ? 1 : 2"></div>\n      <div class="legend-label" style="user-select: none" [style.text-decoration]="serie.visible ? \'none\' : \'line-through\'">{{ serie.name }}</div>\n    </div>\n  </div>\n</ng-container>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[legend_componentngResource_default()]})],LegendComponent);var bandseries_component_class,bandseries_componentngResource=__webpack_require__("./projects/chart/src/chart/stories/bandseries/bandseries.component.scss?ngResource"),bandseries_componentngResource_default=__webpack_require__.n(bandseries_componentngResource);let BandseriesComponent=((bandseries_component_class=class BandseriesComponent extends SeriesBaseComponent{constructor(svc,cdr,scaleService,zoomService,element){super(svc,cdr,scaleService,zoomService,element),this.svc=svc,this.cdr=cdr,this.scaleService=scaleService,this.zoomService=zoomService,this.element=element}ngOnInit(){this.x=this.scaleService.scales.pipe((0,map.U)((_=>_.x.get(this.series.xAxisIndex)?.scale))),this.y=this.scaleService.scales.pipe((0,map.U)((_=>_.y.get(this.series.yAxisIndex)?.scale)))}}).ctorParameters=()=>[{type:ChartService},{type:core.ChangeDetectorRef},{type:ScaleService},{type:ZoomService},{type:core.ElementRef}],bandseries_component_class);BandseriesComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"svg:svg[teta-bandseries]",template:'<ng-container *ngIf="{x: x | async, y: y | async} as scales">\n  <ng-container *ngFor="let band of _series.data">\n    <svg:rect [attr.x]="scales.x(band.x)"\n              [attr.y]="scales.y(band.y) - scales.y.bandwidth() / 2"\n              [attr.width]="scales.x(band.x1) - scales.x(band.x)"\n              fill="red"\n              [attr.height]="scales.y.bandwidth()">\n    </svg:rect>\n    <svg:text\n      text-anchor="middle"\n      dominant-baseline="middle"\n      class="label font-caption fill-text-90"\n      [attr.x]="scales.x(band.x) + (scales.x(band.x1) - scales.x(band.x)) / 2"\n      [attr.y]="scales.y(band.y)">{{band.y}}\n    </svg:text>\n  </ng-container>\n\n</ng-container>\n',styles:[bandseries_componentngResource_default()]})],BandseriesComponent);let ChartModule=class ChartModule{};ChartModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[ChartComponent,SeriesHostComponent,ChartContainerComponent,LegendComponent,SeriesBaseComponent,LinearSeriesBase,LineSeriesComponent,GridlinesComponent,XAxisComponent,YAxisComponent,PlotlineComponent,PlotBandComponent,BarSeriesComponent,TooltipComponent,ZoomableDirective,BrushableDirective,AreaSeriesComponent,ScatterSeriesComponent,BlockSeriesComponent,BlockAreaSeriesComponent,AnnotationComponent,CrosshairComponent,DraggablePointDirective,BandseriesComponent,BlockHorizontalSeriesComponent],exports:[ChartComponent,LegendComponent,SeriesBaseComponent,LineSeriesComponent,BarSeriesComponent,ScatterSeriesComponent,AreaSeriesComponent,BlockSeriesComponent,BlockAreaSeriesComponent,BlockHorizontalSeriesComponent],imports:[common.CommonModule,tetacom_ng_components._NX]})],ChartModule);var icon_module=__webpack_require__("./projects/components/src/component/icon/icon.module.ts"),button_module=__webpack_require__("./projects/components/src/component/button/button.module.ts");const src_int=function sourceRandomInt(source){function randomInt(min,max){return arguments.length<2&&(max=min,min=0),min=Math.floor(min),max=Math.floor(max)-min,function(){return Math.floor(source()*max+min)}}return randomInt.source=sourceRandomInt,randomInt}(Math.random),cssColorNames=["AliceBlue","AntiqueWhite","Aqua","Aquamarine","Azure","Beige","Bisque","Black","BlanchedAlmond","Blue","BlueViolet","Brown","BurlyWood","CadetBlue","Chartreuse","Chocolate","Coral","CornflowerBlue","Cornsilk","Crimson","Cyan","DarkBlue","DarkCyan","DarkGoldenRod","DarkGray","DarkGrey","DarkGreen","DarkKhaki","DarkMagenta","DarkOliveGreen","DarkOrange","DarkOrchid","DarkRed","DarkSalmon","DarkSeaGreen","DarkSlateBlue","DarkSlateGray","DarkSlateGrey","DarkTurquoise","DarkViolet","DeepPink","DeepSkyBlue","DimGray","DimGrey","DodgerBlue","FireBrick","FloralWhite","ForestGreen","Fuchsia","Gainsboro","GhostWhite","Gold","GoldenRod","Gray","Grey","Green","GreenYellow","HoneyDew","HotPink","IndianRed","Indigo","Ivory","Khaki","Lavender","LavenderBlush","LawnGreen","LemonChiffon","LightBlue","LightCoral","LightCyan","LightGoldenRodYellow","LightGray","LightGrey","LightGreen","LightPink","LightSalmon","LightSeaGreen","LightSkyBlue","LightSlateGray","LightSlateGrey","LightSteelBlue","LightYellow","Lime","LimeGreen","Linen","Magenta","Maroon","MediumAquaMarine","MediumBlue","MediumOrchid","MediumPurple","MediumSeaGreen","MediumSlateBlue","MediumSpringGreen","MediumTurquoise","MediumVioletRed","MidnightBlue","MintCream","MistyRose","Moccasin","NavajoWhite","Navy","OldLace","Olive","OliveDrab","Orange","OrangeRed","Orchid","PaleGoldenRod","PaleGreen","PaleTurquoise","PaleVioletRed","PapayaWhip","PeachPuff","Peru","Pink","Plum","PowderBlue","Purple","RebeccaPurple","Red","RosyBrown","RoyalBlue","SaddleBrown","Salmon","SandyBrown","SeaGreen","SeaShell","Sienna","Silver","SkyBlue","SlateBlue","SlateGray","SlateGrey","Snow","SpringGreen","SteelBlue","Tan","Teal","Thistle","Tomato","Turquoise","Violet","Wheat","White","WhiteSmoke","Yellow","YellowGreen"];var faker=__webpack_require__("./node_modules/faker/index.js");const randomColor=src_int(0,cssColorNames.length-1),seriesType=[SeriesType.line,SeriesType.line];faker.locale="ru";const createSeries=size=>seriesType.map(((type,index)=>({id:index,type,name:faker.address.cityName(),yAxisIndex:0,xAxisIndex:0,color:cssColorNames[randomColor()].toLowerCase(),fillType:FillType.gradient,data:Array.from(Array(size).keys()).map(((key,index,arr)=>{const num=faker.datatype.number({min:0,max:6e3}),iconId=faker.datatype.number({min:1,max:14});return{x:num,y:type===SeriesType.block?0:faker.datatype.number({min:0,max:200}),iconId:`icon${iconId}`,text:faker.commerce.productMaterial()}})).sort(((a,b)=>a.x-b.x)).map(((_,index,arr)=>({..._,x:arr[index-1]?.x,x1:_.x})))}))),createDragSeries=size=>({id:"index",type:SeriesType.line,name:faker.address.cityName(),yAxisIndex:0,xAxisIndex:0,color:cssColorNames[randomColor()].toLowerCase(),fillType:FillType.gradient,data:Array.from(Array(size).keys()).map(((key,index,arr)=>({x:index,y:faker.datatype.number({min:0,max:200}),marker:index%33==0?{draggable:!0,dragType:DragPointType.xy,style:{strokeWidth:10,fill:"red"},label:{draggable:!1,text:"index"}}:null})))}),createBandSeries=size=>({id:"index",type:SeriesType.line,name:faker.address.cityName(),yAxisIndex:0,xAxisIndex:0,component:BandseriesComponent,color:cssColorNames[randomColor()].toLowerCase(),data:Array.from(Array(size).keys()).map(((key,index,arr)=>{const x=faker.date.between("2022-09-25T00:00:00.000Z","2022-10-10T00:00:00.000Z"),point={x,x1:new Date(x.getTime()+faker.datatype.number({min:864e4,max:10964e4})),y:faker.address.cityName()};return console.log(point),point}))}),createChart=(size,inverted=!0)=>({name:"123123123132",inverted,tooltip:{tracking:TooltipTracking.y},bounds:new ChartBounds({}),xAxis:[{min:0,max:5e3,visible:!0,inverted:!1,niceTicks:!1,plotLines:[{value:1e3,draggable:!0}]}],yAxis:[{visible:!0}],brush:{type:BrushType.y},zoom:{enable:!0,type:ZoomType.y,syncChannel:"channelA",zoomBehavior:ZoomBehaviorType.wheel,min:100,max:5e3,minTranslate:0,maxTranslate:7e3},legend:{enable:!1},series:createSeries(size)});var angular_dist=__webpack_require__("./node_modules/@storybook/angular/dist/index.mjs"),http=__webpack_require__("./node_modules/@angular/common/fesm2022/http.mjs");const Chart_stories={title:"Component/Chart",decorators:[dist.withKnobs,(0,angular_dist.applicationConfig)({providers:[(0,core.importProvidersFrom)(http.JF)]})],component:ChartComponent,moduleMetadata:{imports:[ChartModule,icon_module.Q,button_module.h]}},basicChart=()=>({moduleMetadata:{imports:[ChartModule,icon_module.Q,button_module.h]},props:{config:createChart(200),createChart,setZoom:function(chart){console.log(chart),chart.scaleService.resetZoom()}},template:'\n\n      <div [tetaIconSprite]="[\'assets/icons.svg\', \'assets/lithotype-icons.svg\']"\n            class="font-body-3 padding-3 bg-global-bgmain"\n            style="width: 100%; height: 100vh">\n        <button teta-button\n          [palette]="\'primary\'"\n          (click)="config=createChart(500);">\n          Create new Data\n        </button>\n        <button teta-button\n          [palette]="\'primary\'"\n          (click)="config=createChart(0); config2=createChart(0)">\n          Create empty data\n          config </button>\n        <button teta-button\n          [palette]="\'primary\'"\n          (click)="setZoom(chart)">Set zoom</button>\n\n        <div class="row row_auto gap" style="height: 100%; width: 100%">\n            <teta-svg-chart #chart [config]="config" class="bg-global-bgcard row_6 border border-text-50"></teta-svg-chart>\n\n        </div>\n\n      </div>\n\n'}),draggableChart=()=>{return{moduleMetadata:{imports:[ChartModule,icon_module.Q,button_module.h]},props:{config:(size=400,{name:"123123123132",inverted:!0,tooltip:{tracking:TooltipTracking.y},bounds:new ChartBounds({}),xAxis:[{niceTicks:!1}],yAxis:[{}],zoom:{enable:!0,type:ZoomType.y},legend:{enable:!1},series:[createDragSeries(size)]})},template:'\n      <div [tetaIconSprite]="[\'assets/icons.svg\', \'assets/lithotype-icons.svg\']"\n            class="font-body-3 padding-3 bg-global-bgmain"\n            style="width: 100%; height: 100vh">\n        <div class="row row_auto gap" style="height: 100%; width: 100%">\n            <teta-svg-chart [config]="config" class="bg-global-bgcard row_6 border border-text-50"></teta-svg-chart>\n        </div>\n      </div>'};var size},bandChart=()=>{return{moduleMetadata:{imports:[ChartModule,icon_module.Q,button_module.h]},props:{config:(size=50,{name:"Band Chart",tooltip:{tracking:TooltipTracking.y},bounds:new ChartBounds({top:30}),xAxis:[{niceTicks:!1,opposite:!0,min:new Date("2022-09-25").getTime(),max:new Date("2022-09-30").getTime(),scaleType:{type:ScaleType.time}}],yAxis:[{visible:!0,scaleType:{type:ScaleType.band}}],zoom:{enable:!0,type:ZoomType.x},legend:{enable:!1},series:[createBandSeries(size)]})},template:'\n      <div [tetaIconSprite]="[\'assets/icons.svg\', \'assets/lithotype-icons.svg\']"\n            class="font-body-3 padding-3 bg-global-bgmain"\n            style="width: 100%; height: 100vh">\n        <div class="row row_auto gap" style="height: 100%; width: 100%">\n            <teta-svg-chart [config]="config" class="bg-global-bgcard row_6 border border-text-50"></teta-svg-chart>\n        </div>\n      </div>'};var size}},"./projects/components/src/component/button/button.module.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{h:()=>ButtonModule});var tslib__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),_angular_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),_angular_common__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),_button_button_component__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./projects/components/src/component/button/button/button.component.ts");let ButtonModule=class ButtonModule{};ButtonModule=(0,tslib__WEBPACK_IMPORTED_MODULE_1__.gn)([(0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule)({declarations:[_button_button_component__WEBPACK_IMPORTED_MODULE_0__.r],imports:[_angular_common__WEBPACK_IMPORTED_MODULE_3__.CommonModule],exports:[_button_button_component__WEBPACK_IMPORTED_MODULE_0__.r]})],ButtonModule)},"./projects/components/src/component/button/button/button.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{r:()=>ButtonComponent});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");var _class,button_componentngResource=__webpack_require__("./projects/components/src/component/button/button/button.component.scss?ngResource"),button_componentngResource_default=__webpack_require__.n(button_componentngResource),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs");let ButtonComponent=((_class=class ButtonComponent{get getClass(){const result=[this.class,"button"];switch(this.palette&&result.push(`button-${this.palette}`),this.view&&result.push(`button_${this.view}`),this.square&&result.push("button-square"),this.size){case"l":result.push("font-button-1");break;case"m":result.push("font-button-2")}return result.push(`button_${this.viewType}`),result.join(" ")}constructor(){this.view="primary",this.square=!1,this.viewType="rounded",this.size="m"}ngOnInit(){}}).ctorParameters=()=>[],_class.propDecorators={palette:[{type:core.Input}],class:[{type:core.Input}],view:[{type:core.Input}],square:[{type:core.Input}],viewType:[{type:core.Input}],size:[{type:core.Input}],getClass:[{type:core.HostBinding,args:["class"]}]},_class);ButtonComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"button[teta-button], teta-button",template:"<ng-content></ng-content>\n",changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[button_componentngResource_default()]})],ButtonComponent)},"./projects/components/src/component/icon/icon.module.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Q:()=>IconModule});var _class,IconService_1,tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),fesm2022_http=__webpack_require__("./node_modules/@angular/common/fesm2022/http.mjs"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js");let IconService=((_class=class IconService{constructor(_document,_rendererFactory,_httpBackend,_http){this._document=_document,this._rendererFactory=_rendererFactory,this._httpBackend=_httpBackend,this._http=_http,this._renderer=this._rendererFactory.createRenderer(null,null)}addSprite(url,bypassInterceptors=!0){IconService_1._loaded.indexOf(url)<0&&IconService_1._pending.indexOf(url)<0&&(IconService_1._pending.push(url),this.getSVG(url,bypassInterceptors).subscribe((svg=>{IconService_1._pending=IconService_1._pending.filter((_=>_!==url)),IconService_1._loaded.push(url),this._renderer.insertBefore(this._document.body,svg,this._document.body.firstChild)})))}getSVG(url,bypassInterceptors=!0){return(bypassInterceptors?new fesm2022_http.eN(this._httpBackend):this._http).get(url,{responseType:"text"}).pipe((0,map.U)((svgText=>{const svgEl=this.svgElementFromString(svgText);return this.cloneSVG(svgEl)})))}svgElementFromString(str){const div=this._renderer.createElement("DIV");div.innerHTML=str;const svg=div.querySelector("svg");if(!svg)throw new Error("No SVG found in loaded contents");return svg}cloneSVG(svg){return svg.cloneNode(!0)}})._loaded=[],_class._pending=[],_class.ctorParameters=()=>[{type:void 0,decorators:[{type:core.Inject,args:[common.DOCUMENT]}]},{type:core.RendererFactory2},{type:fesm2022_http.jN},{type:fesm2022_http.eN}],IconService_1=_class);var icon_sprite_directive_class;IconService=IconService_1=(0,tslib_es6.gn)([(0,core.Injectable)({providedIn:"root"})],IconService);let IconSpriteDirective=((icon_sprite_directive_class=class IconSpriteDirective{constructor(_iconService){this._iconService=_iconService,this.bypassInterceptors=!0}ngOnInit(){"string"==typeof this.tetaIconSprite&&this._iconService.addSprite(this.tetaIconSprite,this.bypassInterceptors),this.tetaIconSprite instanceof Array&&this.tetaIconSprite?.length&&this.tetaIconSprite.forEach((sprite=>{this._iconService.addSprite(sprite,this.bypassInterceptors)}))}}).ctorParameters=()=>[{type:IconService}],icon_sprite_directive_class.propDecorators={tetaIconSprite:[{type:core.Input}],bypassInterceptors:[{type:core.Input}]},icon_sprite_directive_class);IconSpriteDirective=(0,tslib_es6.gn)([(0,core.Directive)({selector:"[tetaIconSprite]"})],IconSpriteDirective);var icon_component=__webpack_require__("./projects/components/src/component/icon/icon/icon.component.ts");let IconModule=class IconModule{};IconModule=(0,tslib_es6.gn)([(0,core.NgModule)({declarations:[icon_component.o,IconSpriteDirective],exports:[icon_component.o,IconSpriteDirective],imports:[common.CommonModule,fesm2022_http.JF]})],IconModule)},"./projects/components/src/component/icon/icon/icon.component.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{o:()=>IconComponent});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs");var TetaSize,_class,icon_componentngResource=__webpack_require__("./projects/components/src/component/icon/icon/icon.component.scss?ngResource"),icon_componentngResource_default=__webpack_require__.n(icon_componentngResource),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs");!function(TetaSize){TetaSize[TetaSize.XS=0]="XS",TetaSize[TetaSize.S=1]="S",TetaSize[TetaSize.M=2]="M",TetaSize[TetaSize.L=3]="L",TetaSize[TetaSize.XL=4]="XL"}(TetaSize||(TetaSize={}));let IconComponent=((_class=class IconComponent{constructor(){this.size=TetaSize.M}get getClass(){const result=[this.class,"icon"];return this.palette&&result.push(`icon-${this.palette}`),result.join(" ")}getName(){return`#${this.name}`}}).propDecorators={name:[{type:core.Input}],size:[{type:core.Input}],palette:[{type:core.Input}],class:[{type:core.Input}],getClass:[{type:core.HostBinding,args:["class"]}]},_class);IconComponent=(0,tslib_es6.gn)([(0,core.Component)({selector:"teta-icon",template:'<svg class="icon__image" style="width: 100%;height: 100%">\n  <use [attr.xlink:href]="getName()"></use>\n</svg>\n',changeDetection:core.ChangeDetectionStrategy.OnPush,styles:[icon_componentngResource_default()]})],IconComponent)},"./projects/chart/src/chart/chart-container/annotation/annotation.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/chart-container.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  min-width: 0;\n  min-height: 0;\n}\n\n:host .zoomable:hover {\n  cursor: grab;\n}\n\n:host .zoomable:active {\n  cursor: grabbing;\n}\n\n:host .crosshair {\n  cursor: crosshair;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/crosshair/crosshair.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  shape-rendering: crispEdges;\n  pointer-events: none;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/gridlines/gridlines.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  shape-rendering: crispEdges;\n}\n\n:host line {\n  stroke: var(--color-text-5);\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/plotband/plot-band.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host .draggable rect:hover {\n  cursor: grab;\n}\n\n:host .draggable rect:active {\n  cursor: grabbing;\n}\n\n:host .x-grabber.resizeable {\n  cursor: col-resize;\n}\n\n:host .y-grabber.resizeable {\n  cursor: row-resize;\n}\n\n:host:hover .grabber {\n  opacity: 0.1;\n}\n\n.grabber {\n  opacity: 0;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/plotline/plotline.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host .x-grabber {\n  cursor: col-resize;\n}\n\n:host .y-grabber {\n  cursor: row-resize;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/area-series/area-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/bar/bar-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/block-area-series/block-area-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/block-horizontal-series/block-horizontal-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/block-series/block-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/line/line-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,".draggable-marker {\n  cursor: move;\n}\n\n.active {\n  stroke-opacity: 0.5;\n}\n\n.marker-grab {\n  opacity: 0;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/series/scatter-series/scatter-series.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,".draggable-marker {\n  cursor: move;\n}\n\n.active {\n  stroke-opacity: 0.5;\n}\n\n.marker-grab {\n  opacity: 0;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/tooltip/tooltip.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  position: absolute;\n  z-index: 2;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/x-axis/x-axis.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host .tick {\n  stroke: var(--color-text-20);\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart-container/y-axis/y-axis.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  shape-rendering: crispEdges;\n}\n\n:host .label-axis {\n  fill: var(--color-text-70);\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/chart/chart.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  width: 100%;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/legend/legend.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,":host {\n  display: flex;\n  grid-gap: 8px;\n  flex-wrap: wrap;\n  align-items: center;\n  justify-content: space-evenly;\n}\n\n:host .legend-item {\n  display: flex;\n  align-items: center;\n}\n\n:host .legend-icon-form {\n  width: 12px;\n}\n\n:host .legend-label {\n  margin-left: 5px;\n}",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/chart/src/chart/stories/bandseries/bandseries.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/components/src/component/button/button/button.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()},"./projects/components/src/component/icon/icon/icon.component.scss?ngResource":(module,__unused_webpack_exports,__webpack_require__)=>{var ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/noSourceMaps.js"),___CSS_LOADER_EXPORT___=__webpack_require__("./node_modules/css-loader/dist/runtime/api.js")(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);___CSS_LOADER_EXPORT___.push([module.id,"",""]),module.exports=___CSS_LOADER_EXPORT___.toString()}}]);